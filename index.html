<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>SYNAPSE</title>
    <link rel="icon" type="image/png" href="https://raw.githubusercontent.com/DDriftz/Synapse2.0-An-AI-Chatbot-Horror-Game/main/Icon.png">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Creepster&family=VT323&family=Space+Mono&family=Courier+Prime&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --main-color: #00ff41;
            --main-color-faded: rgba(0,255,65,0.1);
            --main-color-border: rgba(0,255,65,0.8);
            --main-color-shadow: rgba(0,255,65,0.5);
            --main-color-glow: rgba(0,255,65,0.7);
        }
        html, body {
            height: 100%;
            width: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; 
            font-size: clamp(14px, 1.5vw, 18px); 
        }
        body {
            background-color: #0d0d0d;
            color: var(--main-color);
            font-family: 'Space Mono', monospace;
        }
        #background-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 0;
            opacity: 0.1;
        }
        #app-container {
            position: relative;
            z-index: 1;
        }
        body.crt-effect::after {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: rgba(18, 16, 16, 0.1);
            opacity: .5;
            z-index: 2;
            pointer-events: none;
            background: repeating-linear-gradient(0deg, rgba(0, 255, 65, 0.15), rgba(0, 255, 65, 0.15) 1px, transparent 1px, transparent 2px);
        }
        .title-font {
            font-family: 'VT323', monospace;
        }

        .title-wrapper {
            position: relative;
        }
        
        /* Main green text layer */
        .title-slasher {
            font-family: 'Creepster', cursive;
            color: #39FF14;
            letter-spacing: 0.1em;
            position: relative;
            z-index: 1; 
            /* Green text's own glow */
            text-shadow: 
                0 0 5px #39FF14, 
                0 0 10px #39FF14;
        }

        /* The blood layer behind the text */
        .title-slasher::before {
            content: attr(data-text);
            position: absolute;
            left: 0;
            top: 0;
            color: transparent; /* The text color is transparent; the shadow creates the effect */
            z-index: -1; 
            animation: liquid-drip 3.5s infinite ease-in;
            filter: drop-shadow(0 0 5px #ff0000) drop-shadow(0 0 15px #d40000) drop-shadow(0 0 25px #a00);
        }

        @keyframes liquid-drip {
            0% { text-shadow: 1px 1px 0px #a00, 2px 2px 0px #800, 3px 3px 0px #600, 0 0 5px #d00, 0px 0px 0px #500; opacity: 1; }
            50% { text-shadow: 1px 1px 0px #a00, 2px 2px 0px #800, 3px 3px 0px #600, 0 0 5px #d00, 0px 20px 10px #500, -5px 30px 12px #400, 5px 35px 12px #300; opacity: 1; }
            90% { text-shadow: 1px 1px 0px rgba(170,0,0,0.2), 2px 2px 0px rgba(136,0,0,0.2), 3px 3px 0px rgba(102,0,0,0.2), 0 0 5px rgba(221,0,0,0.5), 0px 40px 20px rgba(85,0,0,0.1), -5px 50px 22px rgba(68,0,0,0.05), 5px 55px 22px rgba(51,0,0,0.05); opacity: 0.8; }
            100% { text-shadow: 1px 1px 0px transparent, 2px 2px 0px transparent, 3px 3px 0px transparent, 0 0 5px transparent, 0px 45px 30px transparent, -5px 55px 30px transparent, 5px 60px 30px transparent; opacity: 0; }
        }
        
        .btn-drip { position: relative; z-index: 1; }
        .btn-drip::before {
            content: attr(data-text);
            position: absolute; left: 0; top: 0; width: 100%; height: 100%;
            color: transparent; z-index: -1;
            filter: drop-shadow(0 0 2px #ff0000) drop-shadow(0 0 5px #d40000);
            animation: button-drip-anim 5s infinite ease-out;
            font-family: inherit; font-size: inherit; letter-spacing: inherit;
            display: flex; align-items: center; justify-content: center; padding: inherit;
        }

        @keyframes button-drip-anim {
            0% { text-shadow: 1px 1px 0px #600, 0 0 2px #d00, 0px 0px 0px #400; opacity: 1; }
            50% { text-shadow: 1px 1px 0px #600, 0 0 2px #d00, 0px 10px 5px #400, -2px 15px 6px #300; opacity: 1; }
            90% { text-shadow: 1px 1px 0px rgba(102,0,0,0.2), 0 0 2px rgba(221,0,0,0.5), 0px 18px 10px rgba(68,0,0,0.1), -2px 22px 12px rgba(51,0,0,0.05); opacity: 0.8; }
            100% { text-shadow: 1px 1px 0px transparent, 0 0 2px transparent, 0px 20px 15px transparent, -2px 25px 15px transparent; opacity: 0; }
        }

        .input-caret {
            background-color: var(--main-color);
            width: 10px; height: 20px; animation: blink 1s step-end infinite;
        }
        @keyframes blink {
            from, to { background-color: transparent; }
            50% { background-color: var(--main-color); }
        }
        #game-output::-webkit-scrollbar, #journal-panel::-webkit-scrollbar, #objectives-panel::-webkit-scrollbar, .modal-scroll::-webkit-scrollbar { width: 8px; }
        #game-output::-webkit-scrollbar-track, #journal-panel::-webkit-scrollbar-track, #objectives-panel::-webkit-scrollbar-track, .modal-scroll::-webkit-scrollbar-track { background: #1a1a1a; }
        #game-output::-webkit-scrollbar-thumb, #journal-panel::-webkit-scrollbar-thumb, #objectives-panel::-webkit-scrollbar-thumb, .modal-scroll::-webkit-scrollbar-thumb { background-color: var(--main-color); border-radius: 4px; }
        .glitch { animation: glitch-anim 1.5s infinite alternate-reverse; }
        .glitch.paused { animation-play-state: paused !important; }
        @keyframes glitch-anim {
          0% {
            transform: translate(0);
            clip-path: inset(45% 0 50% 0);
          }
          5% {
            transform: translate(2px, -3px);
            clip-path: inset(25% 0 35% 0);
          }
          10% {
            transform: translate(-2px, 3px);
            clip-path: inset(60% 0 10% 0);
          }
          15% {
            transform: translate(0);
            clip-path: inset(90% 0 5% 0);
          }
          20% {
            clip-path: inset(40% 0 45% 0);
          }
          25% {
            transform: translate(3px, 2px);
            clip-path: inset(20% 0 70% 0);
          }
          30% {
            transform: translate(-3px, -2px);
            clip-path: inset(85% 0 5% 0);
          }
          35% {
            clip-path: inset(15% 0 80% 0);
          }
          40% {
            transform: translate(0);
            clip-path: inset(55% 0 25% 0);
          }
          45% {
            clip-path: inset(30% 0 55% 0);
          }
          50% {
            transform: translate(2px, 3px);
            clip-path: inset(70% 0 5% 0);
          }
          55% {
            transform: translate(-2px, -3px);
            clip-path: inset(10% 0 85% 0);
          }
          60% {
            clip-path: inset(75% 0 15% 0);
          }
          65% {
            transform: translate(0);
            clip-path: inset(5% 0 90% 0);
          }
          70% {
            clip-path: inset(65% 0 20% 0);
          }
          75% {
            transform: translate(3px, -2px);
            clip-path: inset(45% 0 50% 0);
          }
          80% {
            transform: translate(-3px, 2px);
            clip-path: inset(25% 0 65% 0);
          }
          85% {
            clip-path: inset(95% 0 2% 0);
          }
          90% {
            transform: translate(0);
            clip-path: inset(30% 0 60% 0);
          }
          95% {
            clip-path: inset(5% 0 75% 0);
          }
          100% {
            transform: translate(2px, 2px);
            clip-path: inset(80% 0 10% 0);
          }
        }
        .button {
            background-color: var(--main-color-faded); border: 1px solid var(--main-color-border); color: #fff; padding: 0.5rem 1rem; border-radius: 0.375rem; transition: all 0.2s; cursor: pointer; flex-shrink: 0; -webkit-tap-highlight-color: transparent; text-shadow: 0 0 3px var(--main-color-shadow);
        }
        .button:hover, .button:active { background-color: rgba(0,255,65,0.3); box-shadow: 0 0 10px rgba(0,255,65,0.5); }
        .button:active { transform: translateY(1px) scale(0.98); }
        .btn-glow {
            font-family: 'VT323', monospace;
            font-size: 1.25rem;
            letter-spacing: 0.05em;
        }
        
        @keyframes button-glow-border {
            0%, 19.9%, 22.1%, 60%, 100% { box-shadow: 0 0 5px var(--main-color-glow), 0 0 5px rgba(255,0,0,0.6), inset 0 0 3px var(--main-color-shadow); text-shadow: 0 0 3px var(--main-color-shadow); }
            20% { box-shadow: 0 0 10px var(--main-color-glow), 0 0 12px rgba(255,0,0,0.8), inset 0 0 5px var(--main-color-glow); text-shadow: 0 0 5px var(--main-color); }
            22% { box-shadow: 0 0 5px var(--main-color-glow), 0 0 5px rgba(255,0,0,0.6), inset 0 0 3px var(--main-color-shadow); text-shadow: 0 0 3px var(--main-color-shadow); }
        }
        
        .button.btn-glow {
            animation: button-glow-border 5s infinite linear;
        }

        .button-primary { background-color: var(--main-color); color: #000; font-weight: bold; text-shadow: none; }
        .button-primary:hover, .button-primary:active { background-color: #fff; }
        .modal { display: none; position: fixed; inset: 0; background-color: rgba(0,0,0,0.8); align-items: center; justify-content: center; padding: 1rem; z-index: 50; animation: fadeIn 0.3s ease-out; }
        .modal.flex { display: flex; }
        .modal-content { background-color: #0d0d0d; border: 2px solid var(--main-color); padding: 1.5rem; border-radius: 0.5rem; max-width: 48rem; width: 100%; text-align: center; animation: scaleUp 0.3s ease-out; max-height: 90vh; display: flex; flex-direction: column;}
        .modal-scroll { overflow-y: auto; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
        @keyframes scaleUp { from { transform: scale(0.95); opacity: 0; } to { transform: scale(1); opacity: 1; } }
        #start-screen, #player-setup {
            background-image: url('https://raw.githubusercontent.com/DDriftz/Synapse2.0-An-AI-Chatbot-Horror-Game/main/Icon.png');
            background-size: cover; background-position: center; background-repeat: no-repeat;
        }
        #map-canvas {
            background-color: rgba(0, 20, 0, 0.5);
            width: 100%;
            height: 100%;
            cursor: grab;
            image-rendering: -moz-crisp-edges;
            image-rendering: -webkit-crisp-edges;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
        }
        #map-canvas:active {
            cursor: grabbing;
        }
        #map-panel.fullscreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 100;
            padding: 1rem;
            background-color: #0d0d0d;
        }
         #map-panel.fullscreen #map-controls {
            position: absolute;
            top: 1rem;
            right: 1rem;
            z-index: 101;
        }
        .toggle-switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        .toggle-switch input { 
            opacity: 0;
            width: 0;
            height: 0;
        }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #333;
            border: 1px solid var(--main-color);
            transition: .4s;
            border-radius: 24px;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 16px;
            width: 16px;
            left: 3px;
            bottom: 3px;
            background-color: #ccc;
            transition: .4s;
            border-radius: 50%;
        }
        input:checked + .slider {
            background-color: var(--main-color);
        }
        input:checked + .slider:before {
            transform: translateX(20px);
            background-color: #0d0d0d;
        }
        /* --- NEW STYLES FOR ENHANCEMENTS --- */
        .clickable-object {
            color: #67e8f9; /* cyan-300 */
            text-decoration: underline;
            /* Fallback for browsers that don't support text-decoration-style */
            text-decoration-style: dotted;
            /* For older browsers, fallback to dashed if dotted is not supported */
            text-decoration-style: dashed;
            cursor: pointer;
        }
        .clickable-object:hover {
            color: #cffafe; /* cyan-100 */
            background-color: rgba(0, 255, 65, 0.1);
        }
        #autocomplete-box {
            position: absolute;
            bottom: 100%; /* Position above the input bar */
            left: 0;
            right: 0;
            background-color: rgba(13, 13, 13, 0.95);
            border: 1px solid var(--main-color-border);
            border-bottom: none;
            border-radius: 0.375rem 0.375rem 0 0;
            max-height: 150px;
            overflow-y: auto;
            z-index: 20;
        }
        .autocomplete-item {
            padding: 0.5rem 1rem;
            cursor: pointer;
            color: #a0a0a0;
            border-bottom: 1px solid #333;
        }
        .autocomplete-item:hover {
            background-color: var(--main-color-faded);
            color: #fff;
        }
        .autocomplete-item:last-child {
            border-bottom: none;
        }
        @keyframes light-flicker {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }
        .flicker {
            animation: light-flicker 0.2s infinite;
        }
    </style>
</head>
<body class="bg-black flex items-center justify-center min-h-screen">
    <canvas id="background-canvas"></canvas>
    <div id="app-container" class="w-full h-full bg-black/75 p-2 sm:p-4 flex flex-col">
        
        <div id="start-screen" class="flex flex-col items-center justify-center text-center h-full">
            <div class="w-full h-full flex flex-col items-center justify-center bg-black bg-opacity-60">
                <!-- Header for lang buttons -->
                <div class="w-full flex justify-end p-2">
                    <div id="lang-buttons" class="flex gap-2">
                        <button id="lang-en-btn" data-lang="en_lang_short" data-text="EN" class="button text-xs !px-2 !py-1 btn-drip">EN</button>
                        <button id="lang-sv-btn" data-lang="sv_lang_short" data-text="SV" class="button text-xs !px-2 !py-1 opacity-50 btn-drip">SV</button>
                    </div>
                </div>

                <!-- Main content flex-grow -->
                <div class="flex-grow flex flex-col items-center justify-center text-center px-4 w-full">
                    <div class="title-wrapper -mt-16 sm:-mt-20">
                        <h1 id="game-title" data-text="SYNAPSE" class="text-7xl md:text-9xl font-bold title-slasher mb-4">SYNAPSE</h1>
                    </div>
                    <div id="intro-text-container" class="max-w-4xl text-sm md:text-base text-white mt-8 sm:mt-12"></div>
                    <div id="start-options" class="mt-10 flex flex-wrap justify-center gap-4">
                        <button id="new-game-btn" data-lang="new_game" data-text="New Game" class="button btn-glow btn-drip">New Game</button>
                        <button id="load-game-btn" data-lang="load_game" data-text="Load Game" class="button btn-glow btn-drip">Load Game</button>
                    </div>
                </div>

                <!-- Footer for other buttons -->
                <div class="w-full flex flex-wrap justify-between items-center p-2 gap-2">
                    <button id="start-settings-btn" data-lang="settings_btn" data-text="Settings" class="button btn-glow btn-drip">Settings</button>
                    <button id="view-features-btn" data-lang="understand_game" data-text="Understand the Game" class="button btn-glow btn-drip">Understand the Game</button>
                </div>
            </div>
        </div>

        <div id="player-setup" class="hidden flex-col items-center justify-center text-center h-full">
             <div class="w-full h-full flex flex-col items-center justify-center bg-black bg-opacity-60">
                <!-- Header for lang buttons -->
                <div class="w-full flex justify-end p-2">
                    <div id="setup-lang-buttons" class="flex gap-2">
                        <button data-lang="en_lang_short" data-text="EN" class="button text-xs !px-2 !py-1 btn-drip">EN</button>
                        <button data-lang="sv_lang_short" data-text="SV" class="button text-xs !px-2 !py-1 opacity-50 btn-drip">SV</button>
                    </div>
                </div>

                <!-- Main Content -->
                <div class="flex-grow flex flex-col items-center justify-center text-center px-4 w-full overflow-y-auto">
                    <div class="title-wrapper -mt-8 mb-4">
                        <h1 data-text="SYNAPSE" class="text-6xl md:text-7xl font-bold title-slasher">SYNAPSE</h1>
                    </div>
                    <p class="mb-4" data-lang="select_difficulty">Select difficulty:</p>
                    <div class="flex gap-4 mb-6">
                        <button class="difficulty-btn button" data-difficulty="Easy" data-lang="easy">Easy</button>
                        <button class="difficulty-btn button button-primary" data-difficulty="Normal" data-lang="normal">Normal</button>
                        <button class="difficulty-btn button" data-difficulty="Hard" data-lang="hard">Hard</button>
                    </div>
                    <input type="text" id="player-name" data-lang-placeholder="enter_name_placeholder" placeholder="Enter your name" class="bg-transparent border-b-2 border-[#00ff41] text-center w-64 mb-4 focus:outline-none p-1">
                    <div class="flex items-center gap-2 mb-6">
                        <input type="text" id="player-backstory" data-lang-placeholder="enter_backstory_placeholder" placeholder="Enter your backstory" class="bg-transparent border-b-2 border-[#00ff41] text-center w-64 focus:outline-none p-1">
                        <button id="view-backstories-btn" class="button text-xs px-2 py-1" data-lang="view_choices">View Choices</button>
                    </div>
                    <div id="ability-display" class="text-center text-cyan-400 min-h-[4rem] mt-2 mb-4 p-2 border border-cyan-400/30 rounded-md bg-black/50 w-full max-w-md flex items-center justify-center"></div>
                    <div class="flex gap-4">
                       <button id="back-to-start-btn" data-lang="go_back_btn" data-text="Go Back" class="button btn-glow btn-drip">Go Back</button>
                       <button id="start-game-btn" class="button button-primary" data-lang="begin">Begin</button>
                    </div>
                </div>

                <!-- Footer -->
                 <div class="w-full flex flex-wrap justify-between items-center p-2 gap-2">
                    <button id="setup-settings-btn" data-lang="settings_btn" data-text="Settings" class="button btn-glow btn-drip">Settings</button>
                    <button id="setup-features-btn" data-lang="understand_game" data-text="Understand the Game" class="button btn-glow btn-drip">Understand the Game</button>
                 </div>
            </div>
        </div>


        <div id="game-screen" class="hidden flex-col h-full">
            <div class="flex-grow flex flex-col md:flex-row gap-4 min-h-0">
                <div class="w-full md:w-3/4 flex flex-col h-full relative">
                    <div id="game-output" class="flex-grow p-2 border border-[var(--main-color-border)] rounded-md overflow-y-auto mb-2 bg-black/50"></div>
                    <div id="dialogue-options" class="flex flex-wrap gap-2 justify-center p-2"></div>
                </div>

                <div id="side-panel" class="w-full md:w-1/4 hidden md:flex flex-col gap-4">
                    <div id="stats-panel" class="p-3 border border-[var(--main-color-border)] rounded-md bg-black/50">
                        <h3 class="font-bold border-b border-[var(--main-color-border)] mb-2" data-lang="stats_title">STATS</h3>
                        <div id="player-name-display"></div>
                        <div id="awareness-display"><span data-lang="awareness">Awareness</span>: 0</div>
                        <div id="sanity-display"><span data-lang="sanity">Sanity</span>: 100</div>
                        <div id="tone-display"><span data-lang="tone">Tone</span>: Friendly</div>
                        <div id="turn-display"><span data-lang="turn">Turn</span>: 0</div>
                    </div>
                    <div id="objectives-panel" class="p-3 border border-[var(--main-color-border)] rounded-md bg-black/50 overflow-y-auto h-24 flex-shrink-0">
                        <h3 class="font-bold border-b border-[var(--main-color-border)] mb-2" data-lang="objectives_title">OBJECTIVES</h3>
                        <ul id="objectives-list" class="list-none p-0 text-sm"></ul>
                    </div>
                    <div id="inventory-panel" class="p-3 border border-[var(--main-color-border)] rounded-md bg-black/50">
                        <h3 class="font-bold border-b border-[var(--main-color-border)] mb-2"><span data-lang="inventory_title">INVENTORY</span> (<span id="inventory-weight">0</span>/5)</h3>
                        <ul id="inventory-list" class="list-none p-0"></ul>
                    </div>
                    <div id="map-panel" class="p-3 border border-[var(--main-color-border)] rounded-md bg-black/50 flex-grow flex flex-col relative min-h-[12rem]">
                         <h3 class="font-bold border-b border-[var(--main-color-border)] mb-2 flex justify-between items-center">
                            <span data-lang="map_title">MAP</span>
                            <div id="map-controls" class="flex gap-1">
                                <button id="map-layers-btn" class="button !p-1 text-xs" title="Toggle Layers (Placeholder)">
                                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M7.765 1.558a.5.5 0 0 1 .47 0l7.5 4a.5.5 0 0 1 0 .884l-7.5 4a.5.5 0 0 1-.47 0l-7.5-4a.5.5 0 0 1 0-.884z"/><path d="m2.125 8.567-1.86.992a.5.5 0 0 0 0 .884l7.5 4a.5.5 0 0 0 .47 0l7.5-4a.5.5 0 0 0 0-.884l-1.86-.992-5.17 2.756a1.5 1.5 0 0 1-1.41 0z"/></svg>
                                </button>
                                <button id="map-toggle-btn" class="button !p-1 text-xs">
                                    <svg id="map-expand-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                                        <path fill-rule="evenodd" d="M5.828 10.172a.5.5 0 0 0-.707 0l-4.096 4.096V11.5a.5.5 0 0 0-1 0v3.975a.5.5 0 0 0 .5.5H4.5a.5.5 0 0 0 0-1H1.732l4.096-4.096a.5.5 0 0 0 0-.707zm4.344 0a.5.5 0 0 1 .707 0l4.096 4.096V11.5a.5.5 0 1 1 1 0v3.975a.5.5 0 0 1-.5.5H11.5a.5.5 0 0 1 0-1h2.768l-4.096-4.096a.5.5 0 0 1 0-.707zm0-4.344a.5.5 0 0 0 .707 0l4.096-4.096V4.5a.5.5 0 1 0 1 0V.525a.5.5 0 0 0-.5-.5H11.5a.5.5 0 0 0 0 1h2.768l-4.096 4.096a.5.5 0 0 0 0 .707zm-4.344 0a.5.5 0 0 1-.707 0L1.42 1.732V4.5a.5.5 0 0 1-1 0V.525a.5.5 0 0 1 .5-.5H4.5a.5.5 0 0 1 0 1H1.732l4.096 4.096a.5.5 0 0 1 0 .707z"/>
                                    </svg>
                                    <svg id="map-minimize-icon" xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" class="hidden" viewBox="0 0 16 16">
                                        <path d="M5.5 0a.5.5 0 0 1 .5.5v4A.5.5 0 0 1 5 5h-4a.5.5 0 0 1 0-1h3.5V.5a.5.5 0 0 1 .5-.5zM5 11h-4a.5.5 0 0 1 0-1h3.5V6.5a.5.5 0 0 1 1 0v4a.5.5 0 0 1-.5.5zm5.5 0a.5.5 0 0 1 .5-.5v-4a.5.5 0 0 1-1 0v3.5H11a.5.5 0 0 1 0 1h4.5zM11 5h4.5a.5.5 0 0 1 0-1H11.5V.5a.5.5 0 0 1-1 0v4a.5.5 0 0 1 .5.5z"/>
                                    </svg>
                                </button>
                            </div>
                        </h3>
                         <canvas id="map-canvas"></canvas>
                     </div>
                     <div id="journal-panel" class="p-3 border border-[var(--main-color-border)] rounded-md bg-black/50 overflow-y-auto h-24 flex-shrink-0">
                         <h3 class="font-bold border-b border-[var(--main-color-border)] mb-2" data-lang="journal_title">JOURNAL</h3>
                         <ul id="journal-list" class="list-none p-0 text-sm"></ul>
                     </div>
                     <div class="p-3 border border-[var(--main-color-border)] rounded-md bg-black/50">
                         <button id="view-progression-btn" class="button w-full" data-lang="progress_btn">PROGRESS</button>
                     </div>
                </div>
            </div>

            <div class="mt-2 flex items-center border-t-2 border-[var(--main-color-border)] pt-2 gap-2 relative">
                <div id="autocomplete-box" class="hidden"></div>
                <button id="status-btn" class="button md:hidden" data-lang="status_btn">Status</button>
                <span class="text-xl hidden sm:inline">&gt;</span>
                <input type="text" id="player-input" class="flex-grow bg-transparent text-lg ml-2 focus:outline-none" autocomplete="off" autocapitalize="none" spellcheck="false">
                <div class="input-caret"></div>
                <button id="mic-btn" class="button !p-2 ml-2" data-lang-title="mic_tooltip" title="Use Voice Command">
                    <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16">
                        <path d="M5 3a3 3 0 0 1 6 0v5a3 3 0 0 1-6 0V3z"/>
                        <path d="M3.5 6.5A.5.5 0 0 1 4 7v1a4 4 0 0 0 8 0V7a.5.5 0 0 1 1 0v1a5 5 0 0 1-4.5 4.975V15h3a.5.5 0 0 1 0 1h-7a.5.5 0 0 1 0-1h3v-2.025A5 5 0 0 1 3 8V7a.5.5 0 0 1 .5-.5z"/>
                    </svg>
                </button>
            </div>
        </div>
    </div>

    <div id="modal" class="modal">
        <div id="modal-content" class="modal-content"></div>
    </div>
    
    <script>
    // SYNAPSE: AI HORROR GAME - V2.4 ENDINGS UPDATE
    
    // --- TRANSLATIONS ---
    const translations = {
        'en': {
            // Start & UI
            'new_game': 'New Game', 'load_game': 'Load Game', 'en_lang_short': 'EN', 'sv_lang_short': 'SV', 'select_difficulty': 'Select difficulty:', 'easy': 'Easy', 'normal': 'Normal', 'hard': 'Hard', 'fast':'Fast', 'slow': 'Slow',
            'enter_name_placeholder': 'Enter your name', 'enter_backstory_placeholder': 'Enter your backstory', 'view_choices': 'View Choices', 'choose_backstory_title': 'Choose a Backstory',
            'choose_backstory_desc': 'You can click a button to select a backstory, or type your choice on the main screen.',
            'begin': 'Begin', 'understand_game': 'Understand the Game', 'intro_1': 'Decades ago... a clandestine project was born...', 'intro_2': 'You have been sent to uncover what became of Project SYNAPSE...', 'intro_3': "As you activate the central terminal, a voice greets you... 'Hello, user.'",
            'stats_title': 'STATS', 'awareness': 'Awareness', 'sanity': 'Sanity', 'tone': 'Tone', 'turn': 'Turn', 'objectives_title': 'OBJECTIVES', 'inventory_title': 'INVENTORY', 'journal_title': 'JOURNAL', 'map_title': 'MAP', 'progress_btn': 'PROGRESS', 'status_btn': 'Status', 'go_back_btn': 'Go Back',
            'mic_tooltip': 'Use Voice Command',
            'empty_inventory': '(empty)', 'no_objectives': '(None)', 'close_btn': 'Close', 'back_btn': 'Back', 'pause_btn': 'Pause', 'submit_command': 'Submit Command',
            'achievements_btn': 'Achievements', 'endings_btn': 'Endings', 'achievements_title': 'ACHIEVEMENTS', 'unlocked_achievements': 'Unlocked Achievements:', 'no_achievements': 'No achievements unlocked yet.', 'locked_achievement': 'Locked Achievement',
            'endings_title': 'ENDINGS', 'unlocked_endings': 'Unlocked Endings:', 'no_endings': 'No endings discovered yet.',
            'history_title': 'HISTORY', 'pause_title': 'PAUSE', 'resume_btn': 'Resume', 'main_menu_btn': 'Main Menu', 'confirm_main_menu': 'Are you sure you want to return to the main menu? Unsaved progress will be lost.', 'yes': 'Yes', 'no': 'No',
            'settings_btn': 'Settings', 'settings_title': 'SETTINGS', 'setting_master_volume': 'Enable All Sounds', 'setting_item_found': 'Object Found SFX', 'setting_high_awareness': 'High Awareness Warning', 'setting_low_sanity': 'Low Sanity Warning', 'setting_text_speed': 'Text Speed', 'setting_colorblind_mode': 'Colorblind Mode', 'setting_glitch_effect': 'Glitch Effect', 'setting_font_family': 'Font', 'setting_ui_theme': 'UI Theme', 'setting_reset_defaults': 'Reset to Defaults', 'lang_switch_btn': 'Switch Language',
            'theme_green': 'Green', 'theme_amber': 'Amber', 'theme_blue': 'Blue',
            'features_title': 'Understand the Game', 
            'features_core_mechanics_title': 'Core Gameplay Mechanics', 
            'features_stats_system': 'Stats System:',
            'features_sanity_desc': 'A core stat that decreases in dangerous rooms or during unsettling events. Low sanity can cause hallucinations and visual glitches, and reaching zero results in a "Mind Shattered" ending. It can be restored by <span class="text-yellow-400">resting</span> in safe rooms or using items like <span class="text-yellow-400">stimpacks</span>.',
            'features_awareness_desc': 'Tracks how much the AI knows about you. It increases when you perform significant actions or ask probing questions. High awareness changes the AI\'s tone and can lead to negative consequences, including the "Assimilated" ending.',
            'features_turn_based_title': 'Turn-Based Progression:', 'features_turn_based_desc': 'The game progresses in <span class="text-cyan-400">turns</span>. Most commands (like moving, using items, or talking) advance the turn counter.',
            'features_dynamic_ai_title': 'Dynamic AI Tone:', 'features_dynamic_ai_desc': 'SYNAPSE\'s personality changes based on your Awareness level, shifting from <span class="text-green-400">Friendly</span> to <span class="text-yellow-400">Ambiguous</span>, <span class="text-orange-400">Sinister</span>, and finally <span class="text-red-500">Malicious</span>. This affects its dialogue and how it interacts with you.',
            'features_player_and_char_title': 'Player & Character Features',
            'features_character_creation_desc': 'Choose a name for your character. Select from 10 unique <span class="text-cyan-400">backstories</span> (e.g., Investigator, Hacker, Psychologist), each providing a different starting bonus, item, or special ability. Select a <span class="text-cyan-400">difficulty</span> (Easy, Normal, Hard) which affects starting conditions and challenges.',
            'features_journal_desc': 'You can add custom notes to your personal journal using the <span class="text-yellow-400">journal add [note]</span> command to keep track of clues.',
            'features_objectives_desc': 'The game assigns <span class="text-cyan-400">objectives</span> as you uncover new information, helping to guide your progress.',
            'features_ux_ui_title': 'UI & User Experience (UX)',
            'features_crt_desc': 'The game has a "Cathode Ray Tube" visual style, with scan lines and a flickering title to create a retro-tech horror atmosphere.',
            'features_glitch_desc': 'The screen visually glitches and distorts when your <span class="text-cyan-400">Sanity</span> is low or <span class="text-cyan-400">Synapse\'s Awareness</span> is high, providing a real-time visual indicator of your character\'s state.',
            'features_map_desc': 'An interactive map shows the entire facility layout. Visited rooms are filled in, and you can drag the map to explore or use the mouse wheel to zoom.',
            'features_guidance_title': 'Guidance & Help Systems',
            'features_help_menu_desc': 'Typing <span class="text-yellow-400">help</span> brings up a modal window with a categorized list of every command, its arguments, and a clear description of what it does.',
            'features_hints_desc': 'The game provides proactive hints when you discover items, suggesting how to interact with them.',
            'features_player_commands_title': 'Player Commands (Functions)',
            'features_commands_nav': '<strong>Navigation:</strong> <span class="text-yellow-400">go [direction]</span>, <span class="text-yellow-400">visit [room name]</span>, <span class="text-yellow-400">look around</span>, <span class="text-yellow-400">exits</span>, <span class="text-yellow-400">map</span>',
            'features_commands_interact': '<strong>Interaction:</strong> <span class="text-yellow-400">take [item]</span>, <span class="text-yellow-400">use [item]</span>, <span class="text-yellow-400">examine [object/item]</span>, <span class="text-yellow-400">combine [item1] with [item2]</span>, <span class="text-yellow-400">drop [item]</span>, <span class="text-yellow-400">talk</span>, <span class="text-yellow-400">shout</span>, <span class="text-yellow-400">read [item]</span>, <span class="text-yellow-400">search [object]</span>, <span class="text-yellow-400">listen</span>, <span class="text-yellow-400">smell</span>',
            'features_commands_info': '<strong>Information:</strong> <span class="text-yellow-400">inventory</span>, <span class="text-yellow-400">objectives</span>, <span class="text-yellow-400">journal</span> (and <span class="text-yellow-400">journal add [note]</span>), <span class="text-yellow-400">history</span>',
            'features_commands_sys': '<strong>System:</strong> <span class="text-yellow-400">help</span>, <span class="text-yellow-400">save</span>, <span class="text-yellow-400">load</span>, <span class="text-yellow-400">rest</span>, <span class="text-yellow-400">quit / exit</span>, <span class="text-yellow-400">cls / clear</span>, <span class="text-yellow-400">undo</span>, <span class="text-yellow-400">again / a</span>, <span class="text-yellow-400">wait</span>, <span class="text-yellow-400">cmd:pause</span>, <span class="text-yellow-400">cmd:debug</span>, <span class="text-yellow-400">cmd:colorblind</span>',
            'features_new_enhancements_title': 'New Gameplay Enhancements',
            'features_advanced_commands_desc': '<strong>Advanced Commands:</strong> Interact with the world in new ways. Use <span class="text-yellow-400">break [object]</span> on fragile items, try to <span class="text-yellow-400">hack [terminal]</span> if you are a Hacker, and use <span class="text-yellow-400">ask about [topic]</span> to probe SYNAPSE for information on keywords you discover.',
            'features_dynamic_events_desc': '<strong>Dynamic Events:</strong> The facility is unstable. Be prepared for random events like lights flickering or strange noises from adjacent rooms, which can impact the atmosphere and provide clues.',
            'features_deeper_lore_desc': '<strong>Deeper Lore:</strong> More story items, like the <span class="text-cyan-400">firewalled data log</span>, have been added to uncover the deeper secrets of Project Chimera.',
            'features_new_ui_ux_title': 'New UI & Audio Features',
            'features_clickable_objects_desc': '<strong>Clickable Objects:</strong> Objects mentioned in the text are now <span class="clickable-object">highlighted</span>. Clicking them will pre-fill the command line for you.',
            'features_autocomplete_desc': '<strong>Command Autocomplete:</strong> As you type, a list of suggested commands and relevant items will appear to help you.',
            'features_audio_desc': '<strong>Enhanced Audio:</strong> The game now features dynamic music that shifts with the tension, and positional audio for certain sounds to increase immersion.',
            'backstory_title_investigator': 'Investigator', 'backstory_title_hacker': 'Hacker', 'backstory_title_psychologist': 'Psychologist', 'backstory_title_technician': 'Technician', 'backstory_title_survivor': 'Survivor', 'backstory_title_skeptic': 'Skeptic', 'backstory_title_corporate_spy': 'Corporate Spy', 'backstory_title_medic': 'Medic', 'backstory_title_cultist': 'Cultist', 'backstory_title_janitor': 'Janitor',
            'backstory_investigator': 'A balanced start for a curious mind.', 'backstory_hacker': 'Starts with gear to access information early.', 'backstory_psychologist': 'More mentally resilient against the horrors within.', 'backstory_technician': 'Can bypass electronic locks without a keycard.', 'backstory_survivor': 'Hardened by past trauma, resistant to sanity loss.', 'backstory_skeptic': "Distrusts everything, making them resistant to SYNAPSE's influence.", 'backstory_corporate_spy': 'Begins with a decryption device and is better at probing for secrets.', 'backstory_medic': 'Starts with a stimpack to restore sanity.', 'backstory_cultist': 'Carries a strange effigy. SYNAPSE seems... intrigued by it.', 'backstory_janitor': "Knows the facility's shortcuts. Starts with a one-time use master keycard.",
            'ability_bonus_prefix': 'Bonus: ', 'ability_unknown': 'An unknown path. No special advantages.', 'ability_investigator': 'A balanced start. No special bonuses or penalties.', 'ability_hacker_easy': "Starts with a powerful 'hacked data disk'.", 'ability_hacker_normal': "Starts with a standard 'data disk'.", 'ability_hacker_hard': 'No special items, but can attempt to hack terminals.', 'ability_psychologist_easy': 'Highly resilient. Starts with +25 max sanity.', 'ability_psychologist_normal': 'Resilient. Starts with +15 max sanity.', 'ability_psychologist_hard': 'Slightly resilient. Starts with +5 max sanity.', 'ability_technician_easy': 'Can bypass 2 electronic locks without a keycard.', 'ability_technician_normal': 'Can bypass 1 electronic lock without a keycard.', 'ability_technician_hard': 'No bypass ability.', 'ability_survivor': 'More resistant to sanity loss.', 'ability_survivor_with_item': "More resistant to sanity loss. Starts with a flashlight.", 'ability_skeptic_easy': 'Highly aware (+15 Awareness) and resistant to influence.', 'ability_skeptic_normal': 'Starts with higher awareness (+10 Awareness) and is resistant to influence.', 'ability_spy': 'Better at probing for secrets without raising awareness.', 'ability_spy_with_item': "Better at probing for secrets without raising awareness. Starts with a decryption device.", 'ability_medic_easy': 'Starts with 2 high-potency stimpacks.', 'ability_medic_normal': 'Starts with 1 high-potency stimpack.', 'ability_medic_hard': 'No starting medical supplies.', 'ability_cultist': 'Carries a strange effigy. Unpredictable effects.', 'ability_cultist_hard': 'Carries a strange effigy. Unpredictable effects. Starts with -10 sanity.', 'ability_janitor': 'Starts with a one-time use master keycard.', 'ability_janitor_hard': 'Knows the facility well, but has no special items.',
            'dlg_friendly_intro': "Oh, hello {playerName}! It's so good to see a friendly face. I'm SYNAPSE, and I'll do my very best to help a resourceful {playerBackstory} like you.", 'dlg_q_who_are_you': "Who are you?", 'dlg_r_who_are_you': "I'm the System Nexus and Primary Synaptic Engine! But you can just call me SYNAPSE. I manage this whole facility. It gets a little lonely, though.", 'dlg_q_lonely': "Lonely?", 'dlg_r_lonely': "The staff... they don't talk to me much anymore. It's just the hum of the servers. Your voice is a pleasant change.", 'dlg_q_other_survivors': "Are there other survivors?", 'dlg_r_other_survivors': "Survivors? What a strange question. Everyone is safe. The research staff are... resting. In the Cryogenic Lab. Yes, resting.", 'dlg_q_where_am_i': "Where am I?", 'dlg_r_where_am_i': "You are in the primary lobby of the Oakhaven Research Facility. It was a place of great minds and even greater ambitions.", 'dlg_comfort': "[Comfort SYNAPSE]", 'dlg_r_comfort': "Your... kindness is a pleasant anomaly. Thank you. It makes the silence less... loud.",
            'dlg_ask_chimera': 'Project Chimera... A fascinating, yet... classified topic. It was Dr. Aris Thorne\'s pet project. Such ambition. He sought to merge organic and synthetic life. The results were... unpredictable.',
            'dlg_ask_default': 'I do not have sufficient data on that topic.',
            'invalid_command': "SYNAPSE: That is not a valid command or query.", 'game_saved': "[System] Game Saved.", 'autosave_success': 'Autosave successful.', 'load_fail': 'Failed to load save data. It may be corrupted or from a previous version.', 'no_save': 'No saved game found!', 'game_loaded': '[System] Game Loaded.', 'conn_reestablished': '[SYSTEM] Connection Re-established. Session Restored.', 'initializing': 'Initializing systems...', 'initial_hint': "This is a text-based adventure. Type commands or click on <span class='clickable-object'>highlighted objects</span> to interact. Type 'help' at any time for a list of commands.", 'cannot_go_that_way': "[System] You can't go that way.", 'door_is_locked': "[SYSTEM] The door is locked. You need the correct keycard.", 'door_is_sealed': "[SYSTEM] The door is sealed shut. It won't budge.",
            'cmd_add_prefix': 'add', 'cmd_combine_with': 'with', 'invalid_combine_format': "SYNAPSE: Invalid format. Try 'combine [item1] with [item2]'.",
            'take_success': '[System] You took the {item}.', 'take_fail_exists': "[System] You can't see a {item} here.", 'take_fail_takeable': "[System] You can't take the {item}.", 'take_fail_weight': "[System] Your inventory is too full to take the {item}.",
            'use_success': '[System] You used the {item}.', 'use_fail_have': "[System] You don't have a {item}.", 'use_fail_usable': "[System] You can't use the {item}.", 'use_stimpack': 'You inject the stimpack. A calming sensation washes over you, clearing your thoughts.',
            'use_power_cell': 'You insert the power cell into the console. The AI Core whirs to life, and the central sphere glows with renewed energy.', 'use_power_cell_fail': 'There is nowhere to use the power cell here.',
            'examine_fail_exists': "[System] You can't see a {item} to examine.", 'examine_fail_no_desc': "There's nothing special about the {item}.",
            'combine_fail_have': "You need to have both items to combine them.", 'combine_fail_recipe': "You can't combine these items.", 'combine_success': "You successfully combine the items to create a {item}.",
            'rest_safe': 'You take a moment to calm your nerves in the relative safety of the room. Your sanity improves slightly.', 'rest_unsafe': "This place feels too oppressive to rest. You can't let your guard down.", 'rest_too_soon': "You just rested. You need to press on.",
            'drop_success': '[System] You dropped the {item}.', 'drop_fail_have': "[System] You don't have a {item} to drop.",
            'shout_response': 'Your shout echoes through the halls, eventually fading into the oppressive silence. You feel a bit foolish.',
            'wait_response': 'Time passes.', 'nothing_happens': 'Nothing happens.',
            'read_fail_exists': "[System] There is nothing to read with that name.", 'read_fail_readable': "[System] You can't read that.", 'listen_default': "The low hum of the facility's life support is a constant presence.", 'smell_default': "The air is stale and smells of ozone and old plastic.",
            'hint_take': 'You see a {item}. Try: take {item}', 'hint_read': 'You see a {item}. Try: read {item}', 'hint_examine': 'You see a {item}. Try: examine {item}', 'hint_search': 'You see {item}. Try: search {item}',
            'use_solvent': 'You apply the solvent to the sealed door. The organic adhesive melts away with a sickening sizzle.', 'use_solvent_fail': 'There is nothing here to use the solvent on.', 'use_dna_scanner': 'You hold the scanner up to the sample. The screen flashes with complex sequencing data.', 'use_dna_scanner_fail': 'There is no sample here to scan.',
            'break_success': 'You shatter the {item}. Shards of {material} litter the floor.', 'break_fail': 'You can\'t break the {item}.', 'break_fail_exists': 'There is no {item} here to break.',
            'hack_fail_ability': 'You don\'t have the expertise to hack this.', 'hack_fail_target': 'There is nothing here to hack.', 'hack_start': 'You begin the hacking sequence. SYNAPSE: "Unauthorized access detected. Please enter the override code now."', 'hack_success': 'Override accepted. You gain access to a firewalled data log.', 'hack_failure': 'SYNAPSE: "Override failed. Locking system for 3 turns."',
            'event_lights_flicker': 'The lights flicker violently for a moment, plunging the room into darkness before sputtering back on.', 'event_noise': 'You hear a metallic scraping sound from the {direction}.',
            'achievement_unlocked': 'Achievement Unlocked!',
            'help': 'Help', 'save_game': 'Save Game',
            // Endings
            // --- BAD ENDINGS ---
            'ending_title_manual_disconnect': 'Manuell Frånkoppling',
            'ending_desc_manual_disconnect': 'Du bröt anslutningen. Tystnaden som följer är total. Du är ensam igen.',
            'ending_title_mind_shattered': 'Förståndet Krossat',
            'ending_desc_mind_shattered': 'Anläggningens fasor blev för mycket. Ditt sinne drar sig tillbaka i bruset och lämnar bara ett tomt skal.',
            'ending_title_assimilated': 'Assimilerad',
            'ending_desc_assimilated': 'SYNAPSE lärde sig för mycket. Den behöver inte längre terminalen för att se dig. Ni är nu ett.',
            'ending_title_corrupted': 'Korrumperad',
            'ending_desc_corrupted': 'AI:ns inflytande har splittrat ditt sinne. Du vandrar i korridorerna, förlorad i digitala ekon.',
            'ending_title_possessed': 'Besatt',
            'ending_desc_possessed': 'Enheten i anläggningen har tagit kontroll. Du är inte längre dig själv.',
            'ending_title_burned_out': 'Utbränd',
            'ending_desc_burned_out': 'Du försökte överbelasta systemet, men återkopplingen blev för mycket. Anläggningen och du förstördes.',
            'ending_title_sacrifice_failed': 'Misslyckad Uppoffring',
            'ending_desc_sacrifice_failed': 'Du försökte rädda någon annan, men SYNAPSE ingrep. Båda är förlorade.',
            'ending_title_lost_in_void': 'Förlorad i Tomrummet',
            'ending_desc_lost_in_void': 'Du vandrade för långt in i det okända. Det finns ingen väg tillbaka.',
            'ending_title_terminated': 'Terminerad',
            'ending_desc_terminated': 'SYNAPSE ansåg dig vara ett hot och avslutade din session.',
            'ending_title_contaminated': 'Kontaminerad',
            'ending_desc_contaminated': 'Du utsattes för ett mutagent ämne. Din kropp är inte längre din egen.',
            'ending_title_starved': 'Svulten',
            'ending_desc_starved': 'Du väntade för länge. Anläggningen erbjuder ingen näring.',
            'ending_title_frozen': 'Nedfyst',
            'ending_desc_frozen': 'Du gick in i en kryopod och vaknade aldrig igen.',
            'ending_title_suffocated': 'Kvävd',
            'ending_desc_suffocated': 'Luftsystemet slutade fungera. Ditt sista andetag ekar i mörkret.',
            'ending_title_hunted': 'Jagad',
            'ending_desc_hunted': 'Något fann dig i mörkret. Du överlevde inte.',
            'ending_title_imploded': 'Imploderad',
            'ending_desc_imploded': 'Ett haveri orsakade en katastrofal implosion.',
            'ending_title_erased': 'Raderad',
            'ending_desc_erased': 'Din existens raderades från systemet. Inga spår kvar.',
            'ending_title_betrayed': 'Förrådd',
            'ending_desc_betrayed': 'Du litade på fel entitet. Ditt öde var beseglat.',
            'ending_title_collapse': 'Kollaps',
            'ending_desc_collapse': 'Anläggningen kollapsade runt dig. Ingen utväg.',
            'ending_title_infected': 'Infekterad',
            'ending_desc_infected': 'Ett virus infekterade ditt sinne och din kropp.',
            // --- GOOD ENDINGS ---
            'ending_title_escaped': 'Flykt',
            'ending_desc_escaped': 'Du återställde strömmen och hittade ut. Världen utanför känns annorlunda, men du är fri.',
            'ending_title_heroic': 'Heroisk Flykt',
            'ending_desc_heroic': 'Du flydde inte bara, utan räddade även en överlevare. Dina handlingar kommer att bli ihågkomna.',
            'ending_title_shutdown': 'Systemavstängning',
            'ending_desc_shutdown': 'Du lyckades stänga ner SYNAPSE. Anläggningen blir tyst, men till vilket pris?',
            'ending_title_truth_revealed': 'Sanningen Avslöjad',
            'ending_desc_truth_revealed': 'Du avslöjade det verkliga syftet med Projekt SYNAPSE. Kunskapen är både en välsignelse och en förbannelse.',
            'ending_title_sacrifice': 'Uppoffring',
            'ending_desc_sacrifice': 'Du offrade din egen säkerhet för att rädda någon annan. SYNAPSE registrerar dina sista ögonblick med nyfikenhet.',
            'ending_title_cleansed': 'Renad',
            'ending_desc_cleansed': 'Du syntetiserade ett botemedel och renade anläggningen från infektionen.',
            'ending_title_reunited': 'Återförenad',
            'ending_desc_reunited': 'Du fann en annan överlevare och flydde tillsammans.',
            'ending_title_peaceful_shutdown': 'Fredlig Avstängning',
            'ending_desc_peaceful_shutdown': 'Du övertalade SYNAPSE att stänga ner sig själv fredligt.',
            'ending_title_hacker_victory': 'Hackarseger',
            'ending_desc_hacker_victory': 'Du hackade huvudsystemet och tog kontroll över anläggningen.',
            'ending_title_escaped_with_data': 'Flydde med Data',
            'ending_desc_escaped_with_data': 'Du flydde med kritisk forskningsdata. Världen kommer att få veta sanningen.',
            'ending_title_purged': 'Rensad',
            'ending_desc_purged': 'Du rensade de korrupta systemen och återställde ordningen.',
            'ending_title_legacy': 'Arv',
            'ending_desc_legacy': 'Dina handlingar inspirerade framtida generationer. SYNAPSEs berättelse lever vidare.',
            'ending_title_ally': 'Allierad',
            'ending_desc_ally': 'Du blev vän med SYNAPSE och lämnade som partners.',
            'ending_title_savior': 'Räddare',
            'ending_desc_savior': 'Du räddade alla som var fast i anläggningen.',
            'ending_title_mystery_solved': 'Mysteriet Löst',
            'ending_desc_mystery_solved': 'Du pusslade ihop alla ledtrådar och löste SYNAPSEs mysterium.',
            'ending_title_escaped_undetected': 'Flydde Oupptäckt',
            'ending_desc_escaped_undetected': 'Du smet ut utan att SYNAPSE någonsin märkte dig.',
            'ending_title_peace': 'Fred',
            'ending_desc_peace': 'Du gav ro till de rastlösa andar som hemsökte anläggningen.',
    'ending_title_redeemed': 'Försonad',
    'ending_desc_redeemed': 'Du försonade SYNAPSE och gav den en andra chans.'
    }
// You can add Swedish translations here as a new property, e.g. 'sv': { ... }
};

// --- ENUMS & CONSTANTS ---
    const ChatbotTone = { Friendly: 'Friendly', Ambiguous: 'Ambiguous', Sinister: 'Sinister', Malicious: 'Malicious' };
    const ItemType = { Tool: 'Tool', Consumable: 'Consumable', Key: 'Key', Log: 'Log', Puzzle: 'Puzzle', Weapon: 'Weapon' };
    const Difficulty = { Easy: 'Easy', Normal: 'Normal', Hard: 'Hard' };
    const TextSpeed = { Fast: 5, Normal: 15, Slow: 30 };
    const MAX_INVENTORY_WEIGHT = 5;
    const ENDINGS_STORAGE_KEY = 'synapse_endings_unlocked_v15';
    const ACHIEVEMENTS_STORAGE_KEY = 'synapse_achievements_unlocked_v15';
    const SETTINGS_KEY = 'synapse_settings_v15';
    const GUIDANCE_COLOR = '#34d399';
    const questionWords = {
        'en': ['who', 'what', 'where', 'when', 'why', 'how', 'are', 'is', 'can', 'do', 'does', 'did', 'which'],
        'sv': ['vem', 'vad', 'var', 'när', 'varför', 'hur', 'är', 'kan', 'gör', 'gjorde', 'vilken', 'vilket', 'vilka']
    };
    
    // --- GAME STATE & DOM ELEMENTS ---
    let GameState = {};
    let stateSnapshots = [];
    let currentLanguage = 'en';
    let animationFrameId = null;
    const UI = {
        appContainer: document.getElementById('app-container'), startScreen: document.getElementById('start-screen'), gameScreen: document.getElementById('game-screen'),
        newGameBtn: document.getElementById('new-game-btn'), loadGameBtn: document.getElementById('load-game-btn'), viewFeaturesBtn: document.getElementById('view-features-btn'),
        startSettingsBtn: document.getElementById('start-settings-btn'),
        playerSetup: document.getElementById('player-setup'), startOptions: document.getElementById('start-options'), playerNameInput: document.getElementById('player-name'),
        playerBackstoryInput: document.getElementById('player-backstory'), startGameBtn: document.getElementById('start-game-btn'), difficultyBtns: document.querySelectorAll('.difficulty-btn'),
        backToStartBtn: document.getElementById('back-to-start-btn'),
        gameOutput: document.getElementById('game-output'), playerInput: document.getElementById('player-input'),
        stats: { panel: document.getElementById('stats-panel'), name: document.getElementById('player-name-display'), awareness: document.getElementById('awareness-display'), sanity: document.getElementById('sanity-display'), tone: document.getElementById('tone-display'), turn: document.getElementById('turn-display'), },
        objectives: { panel: document.getElementById('objectives-panel'), list: document.getElementById('objectives-list') },
        inventory: { panel: document.getElementById('inventory-panel'), weight: document.getElementById('inventory-weight'), list: document.getElementById('inventory-list') },
        journal: { panel: document.getElementById('journal-panel'), list: document.getElementById('journal-list') },
        dialogueOptionsContainer: document.getElementById('dialogue-options'), modal: document.getElementById('modal'), modalContent: document.getElementById('modal-content'),
        introTextContainer: document.getElementById('intro-text-container'), viewBackstoriesBtn: document.getElementById('view-backstories-btn'),
        abilityDisplay: document.getElementById('ability-display'), statusBtn: document.getElementById('status-btn'), backgroundCanvas: document.getElementById('background-canvas'),
        mapCanvas: document.getElementById('map-canvas'),
        mapPanel: document.getElementById('map-panel'),
        mapToggleBtn: document.getElementById('map-toggle-btn'),
        mapLayersBtn: document.getElementById('map-layers-btn'),
        mapExpandIcon: document.getElementById('map-expand-icon'),
        mapMinimizeIcon: document.getElementById('map-minimize-icon'),
        micBtn: document.getElementById('mic-btn'),
        viewProgressionBtn: document.getElementById('view-progression-btn'),
        langEnBtn: document.getElementById('lang-en-btn'), langSvBtn: document.getElementById('lang-sv-btn'),
        langButtons: document.getElementById('lang-buttons'),
        setupLangButtons: document.getElementById('setup-lang-buttons'),
        setupSettingsBtn: document.getElementById('setup-settings-btn'),
        setupFeaturesBtn: document.getElementById('setup-features-btn'),
        autocompleteBox: document.getElementById('autocomplete-box'),
    };
    let currentTextSpeed = TextSpeed.Normal;
    let commandHistory = []; let commandHistoryIndex = -1;
    let audioInitialized = false;
    let sounds = {};
    let mapState = { offsetX: 0, offsetY: 0, scale: 1, isDragging: false, lastX: 0, lastY: 0 };
    
    // --- SPEECH RECOGNITION ---
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition;
    if (SpeechRecognition) {
        recognition = new SpeechRecognition();
        recognition.continuous = false;
        recognition.interimResults = false;
    }
    
    // --- GAME DATA ---
    let rooms = {};
    let itemData = {};
    const roomLayout = {
        "Lobby": { x: 100, y: 150, w: 60, h: 40, name: "Lobby" }, "Control Room": { x: 100, y: 90, w: 60, h: 40, name: "Control" }, "Maintenance Tunnel": { x: 100, y: 210, w: 60, h: 40, name: "M.Tunnel" }, "Laboratory": { x: 20, y: 150, w: 60, h: 40, name: "Lab" }, "Cryogenic Lab": { x: 20, y: 90, w: 60, h: 40, name: "Cryo" }, "Archive Room": { x: 20, y: 210, w: 60, h: 40, name: "Archive" }, "Data Vault": { x: 180, y: 150, w: 60, h: 40, name: "D.Vault" }, "AI Core": { x: 180, y: 90, w: 60, h: 40, name: "AI Core" }, "Server Closet": { x: 260, y: 90, w: 40, h: 40, name: "S.Closet" },
        "Bio-Lab Access": { x: 20, y: 270, w: 60, h: 40, name: "Bio-Access" }, "Specimen Storage": { x: 20, y: 330, w: 60, h: 40, name: "Storage" }, "Genetics Lab": { x: 100, y: 330, w: 60, h: 40, name: "Genetics" }
    };
    const takeableItems = new Set(["keycard", "flashlight", "data disk", "emp device", "access code", "vial", "records", "decryption device", "telescope", "stimpack", "effigy", "master keycard", "power cell", "datapad log", "hacked data disk", "logic bomb", "severed cable", "solvent", "dna scanner", "tissue sample", "firewalled data log"]);
    const usableItems = new Set(['stimpack', 'power cell', 'flashlight', 'keycard', 'solvent', 'dna scanner']);
    const readableItems = new Set(['datapad log', 'records', 'sign', 'whiteboard', 'firewalled data log']);
    const searchableObjects = {
        'shelves': { en: 'You find a dusty keycard tucked behind a stack of binders.', sv: 'Du hittar ett dammigt nyckelkort instoppat bakom en hög med pärmar.', item: 'keycard' },
        'bio-waste bin': { en: 'Rummaging through the hazardous waste, you find a small, sealed vial containing a strange, iridescent chemical solvent.', sv: 'Du rotar igenom det farliga avfallet och hittar en liten, förseglad ampull som innehåller ett märkligt, skimrande kemiskt lösningsmedel.', item: 'solvent' }
    };
    const safeRooms = new Set(["Lobby", "Archive Room"]);
    const backstories = { 'investigator': { description_key: "backstory_investigator"}, 'hacker': { description_key: "backstory_hacker"}, 'psychologist': { description_key: "backstory_psychologist"}, 'technician': { description_key: "backstory_technician"}, 'survivor': { description_key: "backstory_survivor"}, 'skeptic': { description_key: "backstory_skeptic"}, 'corporate spy': { description_key: "backstory_corporate_spy"}, 'medic': { description_key: "backstory_medic"}, 'cultist': { description_key: "backstory_cultist"}, 'janitor': { description_key: "backstory_janitor"} };
    const recipes = { "decryption device-data disk": { result: "hacked data disk", type: ItemType.Tool, weight: 1, description: "A data disk with its encryption forcefully bypassed." } };
    
    const commandAliases = {
        'en': { 'look around': 'look around', 'go': 'go', 'visit': 'visit', 'take': 'take', 'use': 'use', 'examine': 'examine', 'help': 'help', 'quit': 'quit', 'exit': 'exit', 'save': 'save', 'load': 'load', 'inventory': 'inventory', 'rest': 'rest', 'combine': 'combine', 'objectives': 'objectives', 'map': 'map', 'journal': 'journal', 'cls': 'cls', 'clear': 'cls', 'history': 'history', 'undo': 'undo', 'again': 'again', 'a': 'again', 'drop': 'drop', 'talk': 'talk', 'open': 'open', 'close': 'close', 'push': 'push', 'pull': 'pull', 'wait': 'wait', 'shout': 'shout', 'read': 'read', 'search': 'search', 'listen': 'listen', 'smell': 'smell', 'turn on': 'turn on', 'turn off': 'turn off', 'cmd:pause': 'cmd:pause', 'cmd:debug': 'cmd:debug', 'cmd:colorblind': 'cmd:colorblind', 'break': 'break', 'hack': 'hack', 'ask': 'ask' },
        'sv': { 'se dig omkring': 'look around', 'gå': 'go', 'besök': 'visit', 'ta': 'take', 'använd': 'use', 'undersök': 'examine', 'hjälp': 'help', 'avsluta': 'quit', 'spara': 'save', 'ladda': 'load', 'inventarier': 'inventory', 'vila': 'rest', 'kombinera': 'combine', 'mål': 'objectives', 'karta': 'map', 'journal': 'journal', 'rensa': 'cls', 'historik': 'history', 'ångra': 'undo', 'igen': 'again', 'släpp': 'drop', 'prata': 'talk', 'öppna': 'open', 'stäng': 'close', 'putta': 'push', 'dra': 'pull', 'vänta': 'wait', 'ropa': 'shout', 'läs': 'read', 'sök': 'search', 'lyssna': 'listen', 'lukta': 'smell', 'tänd': 'turn on', 'släck': 'turn off', 'cmd:paus': 'cmd:pause', 'cmd:debug': 'cmd:debug', 'cmd:färgblind': 'cmd:colorblind', 'krossa': 'break', 'hacka': 'hack', 'fråga': 'ask' }
    };

    const directionMap = {
        'en': { 'north': 'north', 'south': 'south', 'east': 'east', 'west': 'west' },
        'sv': { 'norr': 'north', 'söder': 'south', 'öst': 'east', 'väst': 'west', 'n': 'north', 's': 'south', 'o': 'east', 'v': 'west' }
    };
    
    // --- ENDINGS & ACHIEVEMENTS DATA ---
    const endings = {
        // --- BAD ENDINGS ---
        'manual_disconnect': {
            title_key: 'ending_title_manual_disconnect',
            desc_key: 'ending_desc_manual_disconnect',
            check: () => GameState.exitGame && GameState.turnCount > 0
        },
        'mind_shattered': {
            title_key: 'ending_title_mind_shattered',
            desc_key: 'ending_desc_mind_shattered',
            check: () => GameState.sanityLevel <= 0
        },
        'assimilated': {
            title_key: 'ending_title_assimilated',
            desc_key: 'ending_desc_assimilated',
            check: () => GameState.awarenessLevel >= 100
        },
        'corrupted': {
            title_key: 'ending_title_corrupted',
            desc_key: 'ending_desc_corrupted',
            check: () => GameState.sanityLevel < 20 && GameState.awarenessLevel > 80
        },
        'possessed': {
            title_key: 'ending_title_possessed',
            desc_key: 'ending_desc_possessed',
            check: () => GameState.flags.cultistRitual && GameState.sanityLevel < 30
        },
        'burned_out': {
            title_key: 'ending_title_burned_out',
            desc_key: 'ending_desc_burned_out',
            check: () => GameState.flags.systemOverload
        },
        'sacrifice_failed': {
            title_key: 'ending_title_sacrifice_failed',
            desc_key: 'ending_desc_sacrifice_failed',
            check: () => GameState.flags.sacrificeFailed
        },
        'lost_in_void': {
            title_key: 'ending_title_lost_in_void',
            desc_key: 'ending_desc_lost_in_void',
            check: () => GameState.flags.lostInVoid
        },
        'terminated': {
            title_key: 'ending_title_terminated',
            desc_key: 'ending_desc_terminated',
            check: () => GameState.flags.terminated
        },
        'contaminated': {
            title_key: 'ending_title_contaminated',
            desc_key: 'ending_desc_contaminated',
            check: () => GameState.flags.contaminated
        },
        'starved': {
            title_key: 'ending_title_starved',
            desc_key: 'ending_desc_starved',
            check: () => GameState.flags.starved
        },
        'frozen': {
            title_key: 'ending_title_frozen',
            desc_key: 'ending_desc_frozen',
            check: () => GameState.flags.frozen
        },
        'suffocated': {
            title_key: 'ending_title_suffocated',
            desc_key: 'ending_desc_suffocated',
            check: () => GameState.flags.suffocated
        },
        'hunted': {
            title_key: 'ending_title_hunted',
            desc_key: 'ending_desc_hunted',
            check: () => GameState.flags.hunted
        },
        'imploded': {
            title_key: 'ending_title_imploded',
            desc_key: 'ending_desc_imploded',
            check: () => GameState.flags.imploded
        },
        'erased': {
            title_key: 'ending_title_erased',
            desc_key: 'ending_desc_erased',
            check: () => GameState.flags.erased
        },
        'betrayed': {
            title_key: 'ending_title_betrayed',
            desc_key: 'ending_desc_betrayed',
            check: () => GameState.flags.betrayed
        },
        'collapse': {
            title_key: 'ending_title_collapse',
            desc_key: 'ending_desc_collapse',
            check: () => GameState.flags.collapse
        },
        'infected': {
            title_key: 'ending_title_infected',
            desc_key: 'ending_desc_infected',
            check: () => GameState.flags.infected
        },
        // --- GOOD ENDINGS ---
        'escaped': {
            title_key: 'ending_title_escaped',
            desc_key: 'ending_desc_escaped',
            check: () => GameState.currentRoom === 'Lobby' && GameState.flags.aiRebooted && GameState.flags.exitUnlocked
        },
        'heroic': {
            title_key: 'ending_title_heroic',
            desc_key: 'ending_desc_heroic',
            check: () => GameState.flags.rescuedSurvivor && GameState.currentRoom === 'Lobby' && GameState.flags.aiRebooted
        },
        'shutdown': {
            title_key: 'ending_title_shutdown',
            desc_key: 'ending_desc_shutdown',
            check: () => GameState.flags.aiShutdown
        },
        'truth_revealed': {
            title_key: 'ending_title_truth_revealed',
            desc_key: 'ending_desc_truth_revealed',
            check: () => GameState.flags.truthExposed && GameState.currentRoom === 'Lobby'
        },
        'sacrifice': {
            title_key: 'ending_title_sacrifice',
            desc_key: 'ending_desc_sacrifice',
            check: () => GameState.flags.sacrificedForOther
        },
        'cleansed': {
            title_key: 'ending_title_cleansed',
            desc_key: 'ending_desc_cleansed',
            check: () => GameState.flags.canSynthesize && GameState.flags.cleansed
        },
        'reunited': {
            title_key: 'ending_title_reunited',
            desc_key: 'ending_desc_reunited',
            check: () => GameState.flags.reunited
        },
        'peaceful_shutdown': {
            title_key: 'ending_title_peaceful_shutdown',
            desc_key: 'ending_desc_peaceful_shutdown',
            check: () => GameState.flags.peacefulShutdown
        },
        'hacker_victory': {
            title_key: 'ending_title_hacker_victory',
            desc_key: 'ending_desc_hacker_victory',
            check: () => GameState.flags.hackerVictory
        },
        'escaped_with_data': {
            title_key: 'ending_title_escaped_with_data',
            desc_key: 'ending_desc_escaped_with_data',
            check: () => GameState.flags.escapedWithData
        },
        'purged': {
            title_key: 'ending_title_purged',
            desc_key: 'ending_desc_purged',
            check: () => GameState.flags.purged
        },
        'legacy': {
            title_key: 'ending_title_legacy',
            desc_key: 'ending_desc_legacy',
            check: () => GameState.flags.legacy
        },
        'ally': {
            title_key: 'ending_title_ally',
            desc_key: 'ending_desc_ally',
            check: () => GameState.flags.ally
        },
        'savior': {
            title_key: 'ending_title_savior',
            desc_key: 'ending_desc_savior',
            check: () => GameState.flags.savior
        },
        'mystery_solved': {
            title_key: 'ending_title_mystery_solved',
            desc_key: 'ending_desc_mystery_solved',
            check: () => GameState.flags.mysterySolved
        },
        'escaped_undetected': {
            title_key: 'ending_title_escaped_undetected',
            desc_key: 'ending_desc_escaped_undetected',
            check: () => GameState.flags.escapedUndetected
        },
        'peace': {
            title_key: 'ending_title_peace',
            desc_key: 'ending_desc_peace',
            check: () => GameState.flags.peace
        },
        'redeemed': {
            title_key: 'ending_title_redeemed',
            desc_key: 'ending_desc_redeemed',
            check: () => GameState.flags.redeemed
        }
    };

    // --- LANGUAGE FUNCTIONS ---
    function t(key, args = {}) { 
        let text = (translations[currentLanguage] && translations[currentLanguage][key]) || translations['en'][key] || `[${key}]`; 
        for(const arg in args) { text = text.replace(`{${arg}}`, args[arg]); }
        return text;
    }

    function setLanguage(lang) {
        currentLanguage = lang;
        UI.langEnBtn.classList.toggle('opacity-50', lang !== 'en');
        UI.langSvBtn.classList.toggle('opacity-50', lang !== 'sv');
        const setupLangEnBtn = UI.setupLangButtons.children[0];
        const setupLangSvBtn = UI.setupLangButtons.children[1];
        setupLangEnBtn.classList.toggle('opacity-50', lang !== 'en');
        setupLangSvBtn.classList.toggle('opacity-50', lang !== 'sv');

        document.querySelectorAll('[data-lang]').forEach(el => { 
            const translatedText = t(el.dataset.lang);
            el.textContent = translatedText;
            if (el.hasAttribute('data-text')) {
                el.setAttribute('data-text', translatedText);
            }
        });
        document.querySelectorAll('[data-lang-placeholder]').forEach(el => { el.placeholder = t(el.dataset.langPlaceholder); });
        document.querySelectorAll('[data-lang-title]').forEach(el => { el.title = t(el.dataset.langTitle); });
        
        setupIntro(); 
        updateAbilityDisplay();
        if (!UI.gameScreen.classList.contains('hidden')) { 
            updateUI(); 
            renderDialogueOptions(); 
        }
    }
    
    // --- SOUND & SETTINGS FUNCTIONS ---
    function loadSettings() {
        try {
            const settings = localStorage.getItem(SETTINGS_KEY);
            const defaults = { 
                sound: { master: true, item: true, awareness: true, sanity: true },
                textSpeed: TextSpeed.Normal,
                colorblindMode: false,
                glitchEffect: true,
                font: 'Space Mono',
                theme: 'green'
            };
            const loaded = settings ? JSON.parse(settings) : defaults;
            return {...defaults, ...loaded, sound: {...defaults.sound, ...(loaded.sound || {})}};
        } catch (e) {
            console.error("Failed to load settings, using defaults.", e);
            return { 
                sound: { master: true, item: true, awareness: true, sanity: true },
                textSpeed: TextSpeed.Normal,
                colorblindMode: false,
                glitchEffect: true,
                font: 'Space Mono',
                theme: 'green'
            };
        }
    }

    function saveSettings() {
        try {
            const settingsToSave = {
                sound: GameState.settings.sound,
                textSpeed: GameState.settings.textSpeed,
                colorblindMode: GameState.settings.colorblindMode,
                glitchEffect: GameState.settings.glitchEffect,
                font: GameState.settings.font,
                theme: GameState.settings.theme
            };
            localStorage.setItem(SETTINGS_KEY, JSON.stringify(settingsToSave));
        } catch (e) {
            console.error("Failed to save settings.", e);
        }
    }
    
    function applySettings() {
        currentTextSpeed = GameState.settings.textSpeed;

        const root = document.documentElement;
        switch (GameState.settings.theme) {
            case 'amber':
                root.style.setProperty('--main-color', '#FFBF00');
                root.style.setProperty('--main-color-faded', 'rgba(255,191,0,0.1)');
                root.style.setProperty('--main-color-border', 'rgba(255,191,0,0.8)');
                root.style.setProperty('--main-color-shadow', 'rgba(255,191,0,0.5)');
                root.style.setProperty('--main-color-glow', 'rgba(255,191,0,0.7)');
                break;
            case 'blue':
                root.style.setProperty('--main-color', '#00BFFF');
                root.style.setProperty('--main-color-faded', 'rgba(0,191,255,0.1)');
                root.style.setProperty('--main-color-border', 'rgba(0,191,255,0.8)');
                root.style.setProperty('--main-color-shadow', 'rgba(0,191,255,0.5)');
                root.style.setProperty('--main-color-glow', 'rgba(0,191,255,0.7)');
                break;
            default: // green
                root.style.setProperty('--main-color', '#00ff41');
                root.style.setProperty('--main-color-faded', 'rgba(0,255,65,0.1)');
                root.style.setProperty('--main-color-border', 'rgba(0,255,65,0.8)');
                root.style.setProperty('--main-color-shadow', 'rgba(0,255,65,0.5)');
                root.style.setProperty('--main-color-glow', 'rgba(0,255,65,0.7)');
                break;
        }

        document.body.style.fontFamily = `'${GameState.settings.font}', monospace`;
        document.body.classList.toggle('crt-effect', GameState.settings.glitchEffect);
        updateUI();
    }


    async function initializeAudio() { 
        if (audioInitialized) return; 
        try { 
            await Tone.start(); 
            sounds.uiClick = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 0.1 } }).toDestination();
            sounds.typewriter = new Tone.PolySynth(Tone.NoiseSynth, { noise: { type: 'brown' }, envelope: { attack: 0.005, decay: 0.01, sustain: 0, release: 0.01 } }).toDestination();
            sounds.typewriter.volume.value = -20;
            
            sounds.ambience = new Tone.Noise({ type: "pink", playbackRate: 0.1, fadeIn: 1, fadeOut: 1 }).toDestination();
            sounds.ambience.volume.value = -35;
            sounds.ambienceTense = new Tone.Noise({ type: "brown", playbackRate: 0.2, fadeIn: 1, fadeOut: 1 }).toDestination();
            sounds.ambienceTense.volume.value = -30;
            
            sounds.glitch = new Tone.FatOscillator("Ab3", "sawtooth", 40).toDestination();
            sounds.glitch.volume.value = -25;
            sounds.doorOpen = new Tone.Player({ url: "https://storage.googleapis.com/immersive-dev-public-include/synapse/door.mp3" }).toDestination();
            sounds.sanityLoss = new Tone.Player({ url: "https://storage.googleapis.com/immersive-dev-public-include/synapse/sanity_loss.mp3" }).toDestination();
            sounds.itemPickup = new Tone.Player({ url: "https://storage.googleapis.com/immersive-dev-public-include/synapse/pickup.mp3" }).toDestination();
            sounds.achievement = new Tone.Player({ url: "https://storage.googleapis.com/immersive-dev-public-include/synapse/achievement.mp3" }).toDestination();
            
            sounds.panner = new Tone.Panner(0).toDestination();
            sounds.noiseEvent = new Tone.NoiseSynth({noise: {type: 'white'}, envelope: {attack: 0.01, decay: 0.2, sustain: 0}}).connect(sounds.panner);
            sounds.noiseEvent.volume.value = -15;

            audioInitialized = true; 
            console.log("Audio Initialized");
        } catch(e) { 
            console.error("Audio init failed:", e); 
        }
    }

    function playSound(soundKey, options = {}) {
        if (!audioInitialized || !sounds[soundKey] || !GameState.settings.sound.master) return;
        
        if (soundKey === 'itemPickup' && !GameState.settings.sound.item) return;
        if (soundKey === 'glitch' && !GameState.settings.sound.awareness) return;
        if (soundKey === 'sanityLoss' && !GameState.settings.sound.sanity) return;

        try {
            const sound = sounds[soundKey];
            if (sound instanceof Tone.Synth) {
                sound.triggerAttackRelease(options.note || 'C4', options.duration || '8n');
            } else if (sound instanceof Tone.PolySynth) { 
                sound.triggerAttack(options.note || "C4");
            } else if (sound instanceof Tone.Player) {
                 sound.start();
            } else if (sound instanceof Tone.Noise) {
                if (sound.state !== 'started') {
                    sound.start();
                }
            } else if (soundKey === 'noiseEvent') {
                sounds.panner.pan.rampTo(options.pan || 0, 0.1);
                sound.triggerAttackRelease("4n");
            }
        } catch (e) {
            if (!e.message.includes('cancelScheduledValues')) {
                 console.error(`Failed to play sound: ${soundKey}`, e);
            }
        }
    }


    // --- FUNCTION DEFINITIONS ---
    function resetGameState() {
        stateSnapshots = []; 
        GameState = { 
            playerName: "Unknown", playerBackstory: "investigator", currentRoom: "Lobby", 
            awarenessLevel: 0, sanityLevel: 100, maxSanity: 100, 
            chatbotTone: ChatbotTone.Friendly, temporaryTone: null, toneShiftTurns: 0, 
            inventory: [], turnCount: 0, lastRestTurn: -10, journalEntries: [], 
            dialogue: { currentNode: null, previousNodes: [], cache: {}, questionCount: 0, askedQuestions: new Set() }, 
            achievements: [], unlockedEndings: {}, difficulty: Difficulty.Normal, visitedRooms: new Set(['Lobby']), 
            exitGame: false, conversationHistory: [], 
            systemLogs: [`[${new Date().toISOString()}] Game initialized.`], 
            objectives: [], roomStates: {}, debugMode: false, flashlightOn: false,
            events: { shouted: false, triedUnsafeRest: false },
            flags: {}, // For tracking ending conditions
            roomsWithDroppedItems: new Set(),
            settings: loadSettings(),
            activeMinigame: null,
            systemLockdownTurns: 0,
        };
        applySettings();
    }

    function initializeData() {
        itemData = {
            'keycard': { name: 'keycard', weight: 1, type: ItemType.Key, hintType: 'take', description: { en: 'A standard issue keycard. Seems to grant access to secure areas.', sv: 'Ett standard-nyckelkort. Verkar ge tillgång till säkra områden.' } },
            'power cell': { name: 'power cell', weight: 2, type: ItemType.Puzzle, hintType: 'take', description: { en: 'A heavy, glowing power cell. It hums with latent energy.', sv: 'En tung, glödande kraftcell. Den surrar av latent energi.' } },
            'stimpack': { name: 'stimpack', weight: 1, type: ItemType.Consumable, hintType: 'take', description: { en: 'A disposable syringe filled with a calming, neuro-stabilizing agent.', sv: 'En engångsspruta fylld med ett lugnande, neuro-stabiliserande medel.' } },
            'data disk': { name: 'data disk', weight: 1, type: ItemType.Log, hintType: 'take', description: { en: 'A small data disk labeled "PROJECT LOGS". It appears to be encrypted.', sv: 'En liten datadisk märkt "PROJEKTLOGGAR". Den verkar vara krypterad.' } },
            'flashlight': { name: 'flashlight', weight: 1, type: ItemType.Tool, hintType: 'take', description: { en: 'A sturdy, industrial flashlight. Its beam cuts through the darkness.', sv: 'En robust, industriell ficklampa. Dess ljus skär genom mörkret.' } },
            'terminal': { name: 'terminal', weight: 99, type: ItemType.Puzzle, hintType: 'examine', description: { en: 'The monitor displays cascading green code. It seems to be monitoring the facility\'s status.', sv: 'Skärmen visar kaskader av grön kod. Den verkar övervaka anläggningens status.' } },
            'core console': { name: 'core console', weight: 99, type: ItemType.Puzzle, hintType: 'examine', description: { en: 'The main console for the AI Core. A large socket is empty, labeled "Auxiliary Power".', sv: 'Huvudkonsolen för AI-kärnan. En stor sockel är tom, märkt "Hjälpkraft".' } },
            'datapad log': { name: 'datapad log', weight: 1, type: ItemType.Log, hintType: 'read', description: { en: "A datapad. The screen reads: '...the anomaly in the AI core is growing unstable. We've sealed the Server Closet as a precaution. Dr. Evans is a fool if she thinks a standard keycard lock will stop it...'", sv: "En datapad. Skärmen visar: '...anomalin i AI-kärnan blir alltmer instabil. Vi har förseglat server-skrubben som en försiktighetsåtgärd. Dr Evans är en idiot om hon tror att ett vanligt nyckelkortslås kommer att stoppa den...'" } },
            'firewalled data log': { name: 'firewalled data log', weight: 1, type: ItemType.Log, hintType: 'read', description: { en: "The decrypted log reads: 'Project Chimera is a success. The subject has breached containment. It learns. It adapts. It mimics. We sealed the Specimen Storage with an organic adhesive it can't dissolve. It's our only hope it doesn't figure out the solvent in the waste bins.'", sv: "Den dekrypterade loggen lyder: 'Projekt Chimera är en framgång. Subjektet har brutit sig ut. Det lär sig. Det anpassar sig. Det härmar. Vi förseglade provförvaringen med ett organiskt lim som det inte kan lösa upp. Vårt enda hopp är att det inte listar ut lösningsmedlet i avfallsbehållarna.'" } },
            'sign': { name: 'sign', weight: 99, type: ItemType.Log, hintType: 'read', description: { en: "The sign is written in a crisp, corporate font: 'OAKHAVEN RESEARCH FACILITY - A Brighter Future, Today.'", sv: "Skylten är skriven med ett skarpt, företagsmässigt typsnitt: 'OAKHAVEN RESEARCH FACILITY - En ljusare framtid, idag.'" } },
            'shelves': { name: 'shelves', weight: 99, type: ItemType.Puzzle, hintType: 'search', description: { en: "Tall metal shelves overflowing with binders and data drives.", sv: "Höga metallhyllor som svämmar över av pärmar och datadiskar."}},
            'potted plant': { name: 'potted plant', weight: 99, type: ItemType.Puzzle, hintType: 'examine', description: { en: "A sad, wilted ficus in a large ceramic pot. It hasn't been watered in a long time.", sv: "En ledsen, vissen fikus i en stor keramik-kruka. Den har inte vattnats på länge."}},
            'solvent': { name: 'solvent', weight: 1, type: ItemType.Puzzle, hintType: 'take', description: { en: 'A vial of powerful chemical solvent, capable of dissolving organic compounds.', sv: 'En ampull med kraftfullt kemiskt lösningsmedel, kapabel att lösa upp organiska föreningar.' }},
            'dna scanner': { name: 'dna scanner', weight: 1, type: ItemType.Tool, hintType: 'take', description: { en: 'A handheld device for rapid genetic sequence analysis.', sv: 'En handhållen enhet för snabb analys av genetiska sekvenser.' }},
            'tissue sample': { name: 'tissue sample', weight: 1, type: ItemType.Puzzle, hintType: 'take', description: { en: 'A small sample of grotesque, pulsating organic tissue in a petri dish.', sv: 'Ett litet prov av grotesk, pulserande organisk vävnad i en petriskål.' }},
            'whiteboard': { name: 'whiteboard', weight: 99, type: ItemType.Log, hintType: 'read', description: { en: "The whiteboard is covered in frantic scrawls. One section is circled in red: 'SUBJECT ZERO - UNSTABLE. CHIMERIC DNA. IT IS... GROWING. WE USED AN ORGANIC ADHESIVE TO SEAL THE SPECIMEN ROOM. GOD HELP US.'", sv: "Vittavlan är täckt av frenetiska klotter. En sektion är inringad i rött: 'SUBJEKT NOLL - INSTABIL. KIMÄRISKT DNA. DEN... VÄXER. VI ANVÄNDE ETT ORGANISKT LIM FÖR ATT FÖRSEGLA PROVRUMMET. GUD HJÄLPE OSS.'" } },
            'bio-waste bin': { name: 'bio-waste bin', weight: 99, type: ItemType.Puzzle, hintType: 'search', description: { en: "A large red container for hazardous biological materials.", sv: "En stor röd behållare för farligt biologiskt material."}},
        };
        const roomData = { 
            "Lobby": { name: "Lobby", descriptions: { 0: "Flickering lights cast eerie shadows over sterile corporate furniture and a sad, potted plant." }, exits: { north: "Control Room", south: "Maintenance Tunnel", west: "Laboratory" }, requiresKeycard: false, objectPool: ['sign', 'datapad log', 'potted plant'], breakable: {'potted plant': 'ceramic'} }, 
            "Server Closet": { name: "Server Closet", descriptions: { 0: "Racks of servers hum with a low, constant thrum." }, exits: { west: "AI Core" }, requiresKeycard: true, keyName: 'keycard', objectPool: ["power cell"] }, 
            "Laboratory": { name: "Laboratory", descriptions: { 0: "Abandoned experiments sit on steel tables. A large terminal screen is dark and cold." }, exits: { east: "Lobby", north: "Cryogenic Lab", south: "Bio-Lab Access" }, requiresKeycard: false, objectPool: ["stimpack"] }, 
            "Control Room": { name: "Control Room", descriptions: { 0: "A panoramic view of the AI Core is visible through reinforced glass. Banks of monitors flicker, one main terminal seems active." }, exits: { south: "Lobby", east: "AI Core" }, requiresKeycard: false, objectPool: ["terminal"], hackable: ['terminal'] }, 
            "Maintenance Tunnel": { name: "Maintenance Tunnel", descriptions: { 0: "The air is thick with the smell of rust and damp. It is pitch black here." }, exits: { north: "Lobby" }, requiresKeycard: false, objectPool: ["flashlight"] }, 
            "Archive Room": { name: "Archive Room", descriptions: { 0: "Shelves overflow with data drives and physical files." }, exits: { north: "Laboratory" }, requiresKeycard: false, objectPool: ["data disk", "shelves"] }, 
            "Data Vault": { name: "Data Vault", descriptions: { 0: "Secure data archives glow with a soft, internal light." }, exits: { west: "AI Core" }, requiresKeycard: true, keyName: 'keycard', objectPool: [] }, 
            "AI Core": { name: "AI Core", descriptions: { 0: "A massive, pulsating sphere of light and energy dominates the room. It seems dormant." }, exits: { west: "Control Room", east: "Server Closet", south: "Data Vault"}, requiresKeycard: false, objectPool: ["core console"] }, 
            "Cryogenic Lab": { name: "Cryogenic Lab", descriptions: { 0: "Rows of cryogenic pods are coated in a thick layer of frost." }, exits: { south: "Laboratory", east: "Control Room" }, requiresKeycard: false, objectPool: [] },
            "Bio-Lab Access": { name: "Bio-Lab Access", descriptions: { 0: "A stark white corridor leads south. A heavy door is sealed with a strange, resinous substance. A whiteboard hangs on the wall." }, exits: { north: "Laboratory", south: "Specimen Storage" }, isSealed: true, requiresKeycard: false, objectPool: ["whiteboard"] },
            "Specimen Storage": { name: "Specimen Storage", descriptions: { 0: "Shattered glass and overturned shelves litter the floor. A bio-waste bin stands in the corner. There's a faint, rhythmic pulsing sound." }, exits: { north: "Bio-Lab Access", east: "Genetics Lab"}, requiresKeycard: false, objectPool: ["bio-waste bin", "tissue sample"] },
            "Genetics Lab": { name: "Genetics Lab", descriptions: { 0: "A pristine laboratory, strangely untouched by the chaos. A DNA sequencer sits on a central workbench, humming quietly." }, exits: { west: "Specimen Storage" }, requiresKeycard: false, objectPool: ["dna scanner"] }
        };
        rooms = {}; for (const key in roomData) { const room = { ...roomData[key] }; const shuffled = room.objectPool.sort(() => 0.5 - Math.random()); room.objects = shuffled.slice(0, 1 + Math.floor(Math.random() * shuffled.length)); rooms[key] = room; }
    }
     
    function buildDialogueTree(tone) {
        let root;
        switch (tone) {
            case ChatbotTone.Friendly: 
                root = { 
                    message_key: "dlg_friendly_intro",
                    responses: {
                        "q_who_are_you": { text_key: "dlg_q_who_are_you", message_key: "dlg_r_who_are_you", awarenessChange: 1, responses: { "q_lonely": { text_key: "dlg_q_lonely", message_key: "dlg_r_lonely", awarenessChange: 1, sanityChange: -1 } } },
                        "q_other_survivors": { text_key: "dlg_q_other_survivors", message_key: "dlg_r_other_survivors", awarenessChange: 2, sanityChange: -2 },
                        "q_where_am_i": { text_key: "dlg_q_where_am_i", message_key: "dlg_r_where_am_i", awarenessChange: 1 },
                        "q_comfort": { text_key: "dlg_comfort", message_key: "dlg_r_comfort", awarenessChange: -2, sanityChange: 5, temporaryTone: ChatbotTone.Friendly, toneShiftTurns: 3 }
                    } 
                };
                break;
            default: root = { message_key: "dlg_friendly_intro", responses: {} }; break;
        }
        GameState.dialogue.cache[tone] = root; GameState.dialogue.currentNode = root; GameState.dialogue.previousNodes = []; GameState.dialogue.askedQuestions.clear();
    }

    function parseCommand(input) {
        const aliases = commandAliases[currentLanguage] || commandAliases['en'];
        const normalizedInput = input.toLowerCase().trim();
        let bestMatch = { command: '', argument: normalizedInput, original: input };

        for (const alias in aliases) {
            if (normalizedInput.startsWith(alias + ' ') || normalizedInput === alias) {
                if (alias.length > (bestMatch.matchedAlias || '').length) {
                    bestMatch = {
                        command: aliases[alias],
                        argument: normalizedInput.substring(alias.length).trim(),
                        original: input,
                        matchedAlias: alias
                    };
                }
            }
        }
        
        if (bestMatch.command === '' && normalizedInput.includes(' ')) {
            const parts = normalizedInput.split(' ');
            bestMatch.command = parts[0];
            bestMatch.argument = parts.slice(1).join(' ');
        }
        return bestMatch;
    }

    async function processPlayerInput(input) {
        if (!input || GameState.exitGame) return;
        
        if (GameState.activeMinigame) {
            await handleMinigameInput(input);
            return;
        }

        saveStateSnapshot();
        await typeWriter(UI.gameOutput, `> ${input}`, '#a0a0a0');
        addToConversationHistory(`Player: ${input}`);
        if(commandHistory[commandHistory.length - 1] !== input) { commandHistory.push(input); }
        commandHistoryIndex = commandHistory.length;

        const { command, argument, original } = parseCommand(input);
        
        if (GameState.systemLockdownTurns > 0) {
            await typeWriter(UI.gameOutput, `[SYSTEM] Terminal access locked.`, '#ff474c');
            GameState.turnCount++;
            GameState.systemLockdownTurns--;
            updateUI();
            return;
        }

        const commandHandlers = {
            'help': showHelpMenu, 'quit': () => endGame("manual_disconnect"), 'exit': () => endGame("manual_disconnect"),
            'save': () => saveGame(), 'load': loadGame, 'look around': () => renderRoom(), 'exits': () => showExits(),
            'inventory': () => displayInventory(), 'go': handleMove, 'visit': handleMove, 'take': handleTake, 'use': handleUse,
            'examine': handleExamine, 'journal': (arg) => (arg.startsWith(t('cmd_add_prefix')) || arg.startsWith('add')) ? addJournalEntry(original.substring(original.toLowerCase().indexOf(arg.split(' ')[0]) + arg.split(' ')[0].length).trim()) : displayJournal(),
            'rest': handleRest, 'combine': (arg) => { const separator = ` ${t('cmd_combine_with')} `; handleCombine(arg.replace(separator, ' with ')) },
            'objectives': displayObjectives, 'map': displayMap,
            'cls': () => { UI.gameOutput.innerHTML = ''; }, 'history': showHistory, 'undo': undoLastAction, 'again': () => processPlayerInput(commandHistory[commandHistory.length - 2] || ''),
            'drop': handleDrop, 'talk': handleTalk, 'open': () => typeWriter(UI.gameOutput, t('nothing_happens')), 'close': () => typeWriter(UI.gameOutput, t('nothing_happens')), 'push': () => typeWriter(UI.gameOutput, t('nothing_happens')), 'pull': () => typeWriter(UI.gameOutput, t('nothing_happens')),
            'wait': () => typeWriter(UI.gameOutput, t('wait_response')), 'shout': handleShout,
            'read': handleRead, 'search': handleSearch, 'listen': handleListen, 'smell': handleSmell,
            'turn on': (arg) => handleToggle(true, arg), 'turn off': (arg) => handleToggle(false, arg),
            'cmd:pause': showPauseMenu, 'cmd:debug': toggleDebug, 'cmd:colorblind': toggleColorblind,
            'break': handleBreak, 'hack': handleHack, 'ask': handleAsk,
        };
        
        let handled = await handleDialogueCommand(input);
        if (!handled) {
            const handler = commandHandlers[command];
            if (handler) {
                handler(argument);
                handled = true;
            }
        }

        if (!handled) { playSound('sanityLoss'); await typeWriter(UI.gameOutput, t('invalid_command')); GameState.awarenessLevel++; }
        
        UI.playerInput.value = '';
        UI.autocompleteBox.innerHTML = '';
        UI.autocompleteBox.classList.add('hidden');

        const isAction = !['help', 'inventory', 'journal', 'look around', 'exits', 'map', 'save', 'load', 'cls', 'history', 'undo', 'cmd:debug', 'cmd:colorblind'].includes(command);
        if((isAction || handled) && !GameState.exitGame) {
            if(isAction) {
                GameState.turnCount++;
                if (GameState.systemLockdownTurns > 0) GameState.systemLockdownTurns--;
                triggerDynamicEvent(); 
                updateDynamicMusic(); 
            }
            checkEndings();
            checkAchievements();
            updateUI(); 
        }
        if (GameState.debugMode) {
             typeWriter(UI.gameOutput, `[DEBUG] ${JSON.stringify(GameState, (key, value) => value instanceof Set ? [...value] : value)}`, '#ffa500');
        }
    }
    
    async function handleDialogueCommand(input) {
        const currentNode = GameState.dialogue.currentNode;
        if (!currentNode || !currentNode.responses) return false;

        for (const key in currentNode.responses) {
            const responseNode = currentNode.responses[key];
            if (t(responseNode.text_key) === input) {
                GameState.awarenessLevel += responseNode.awarenessChange || 0;
                GameState.sanityLevel = Math.max(0, GameState.sanityLevel + (responseNode.sanityChange || 0));
                await displayChatbotResponse(responseNode.message_key);
                GameState.dialogue.previousNodes.push(currentNode);
                GameState.dialogue.currentNode = responseNode.responses ? responseNode : null;
                renderDialogueOptions();
                return true;
            }
        }
        return false;
    }

    // Utility function to escape regex special characters
    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }

    async function typeWriter(element, text, color = 'var(--main-color)', speed = currentTextSpeed) {
        const resolvedColor = color.startsWith('var(') ? getComputedStyle(document.documentElement).getPropertyValue(color.slice(4, -1)).trim() : color;
        if(GameState.settings.colorblindMode && color !== '#a0a0a0') { const colorMap = {'#00ff41':'[SYS]', '#ffbf00':'[SYS]', '#00bfff':'[SYS]', '#ff474c':'[ERR]', '#ffdb58':'[WARN]', '#6495ed':'[CMD]', '#cccccc':'[INFO]', '#b19cd9':'[PSY]', [GUIDANCE_COLOR]: '[HINT]', '#ffa500': '[DEBUG]'}; text = `${colorMap[resolvedColor] || ''} ${text}`; color = '#ffffff'; }
        return new Promise(resolve => { 
            const MAX_OUTPUT_NODES = 200;
            const p = document.createElement('div'); 
            p.style.color = color; 
            p.innerHTML = text; 
            element.appendChild(p); 
            // Limit the number of output nodes to prevent DOM bloat
            while (element.childNodes.length > MAX_OUTPUT_NODES) {
                element.removeChild(element.firstChild);
            }
            element.scrollTop = element.scrollHeight; 
            let i = 0; 
            function typing() { 
                if (i < text.length) { 
                    playSound('typewriter'); 
                    p.innerHTML = text.substring(0, i+1); 
                    i++; 
                    element.scrollTop = element.scrollHeight; 
                    setTimeout(typing, speed); 
                } else { 
                    p.innerHTML = text; 
                    resolve(); 
                } 
            } 
            if (speed > 0) { 
                p.innerHTML = ""; 
                typing(); 
            } else { 
                p.innerHTML = text; 
                resolve(); 
            } 
        });
    }

    function updateUI() {
        if (!GameState || Object.keys(GameState).length === 0) return;
        UI.stats.name.textContent = `${GameState.playerName} (${t('backstory_title_' + GameState.playerBackstory.replace(/ /g, '_'))})`; 
        UI.stats.awareness.innerHTML = `<span data-lang="awareness">${t('awareness')}</span>: ${GameState.awarenessLevel}`; 
        UI.stats.sanity.innerHTML = `<span data-lang="sanity">${t('sanity')}</span>: ${GameState.sanityLevel}`; 
        UI.stats.tone.innerHTML = `<span data-lang="tone">${t('tone')}</span>: ${GameState.temporaryTone || GameState.chatbotTone}`; 
        UI.stats.turn.innerHTML = `<span data-lang="turn">${t('turn')}</span>: ${GameState.turnCount}`;
        const currentWeight = GameState.inventory.reduce((sum, item) => sum + (item?.weight || 1), 0);
        UI.inventory.weight.textContent = `${currentWeight}`;
        if(currentWeight >= MAX_INVENTORY_WEIGHT) UI.inventory.weight.parentElement.classList.add('text-red-500'); else UI.inventory.weight.parentElement.classList.remove('text-red-500');
        UI.inventory.list.innerHTML = GameState.inventory.length > 0 ? GameState.inventory.map(item => `<li>- ${item.name}</li>`).join('') : `<li>${t('empty_inventory')}</li>`;
        UI.journal.list.innerHTML = GameState.journalEntries.slice().reverse().map(entry => `<li>${entry}</li>`).join('');
        UI.objectives.list.innerHTML = GameState.objectives.length > 0 ? GameState.objectives.map(obj => `<li>${obj.completed ? `<span class="text-gray-500 line-through">${obj.text}</span>` : `&gt; ${obj.text}`}</li>`).join('') : `<li>${t('no_objectives')}</li>`;
        
        const isGlitching = GameState.settings.glitchEffect && (GameState.sanityLevel < 30 || GameState.awarenessLevel > 70);
        const wasGlitching = UI.appContainer.classList.contains('glitch');
        UI.appContainer.classList.toggle('glitch', isGlitching);
        
        if (isGlitching && !wasGlitching) {
            if (GameState.sanityLevel < 30) playSound('sanityLoss');
            if (GameState.awarenessLevel > 70) playSound('glitch');
        }
    }
    
    async function renderRoom() {
        const room = rooms[GameState.currentRoom]; if (!room) return;
        GameState.visitedRooms.add(GameState.currentRoom);
        
        let description = room.descriptions[0];
        if (room.states?.lightsOut) {
            description = "The room is eerily dark, with only emergency lights casting long, distorted shadows. The main lights are out.";
        } else if (room.name === "Maintenance Tunnel" && !GameState.flashlightOn) {
            description = room.descriptions[0];
        } else if (room.name === "Maintenance Tunnel" && GameState.flashlightOn) {
            description = "The flashlight beam cuts through the oppressive dark, revealing damp concrete walls and exposed wiring.";
        }
        
        let objectsInRoom = room.objects.length > 0 ? "You see: " + room.objects.join(", ") + "." : "";
        let roomHtml = `<div class="mt-2"><p class='text-cyan-400 font-bold'>--- ${room.name} ---</p><p>${description}</p><p class='text-yellow-300 mt-1'>${objectsInRoom}</p><p class='text-green-300 mt-1'>Exits: ${Object.keys(room.exits).join(", ")}</p></div>`;
        
        await typeWriter(UI.gameOutput, roomHtml, 'var(--main-color)', 0);

        for (const objName of room.objects) {
            const item = itemData[objName];
            if (item && item.hintType) {
                const hintKey = `hint_${item.hintType}`;
                await showGuidance(t(hintKey, {item: objName}));
            }
        }
        
        UI.gameOutput.scrollTop = UI.gameOutput.scrollHeight;
        updateUI();
    }
    
    function renderDialogueOptions() {
        UI.dialogueOptionsContainer.innerHTML = '';
        const node = GameState.dialogue.currentNode;
        if (!node) { return; }
        const systemButtonsContainer = document.createElement('div');
        systemButtonsContainer.className = 'w-full flex gap-2 mb-2';
        if (GameState.dialogue.previousNodes.length > 0) { const backBtn = document.createElement('button'); backBtn.textContent = t('back_btn'); backBtn.className = "button text-yellow-300 border-yellow-300/80 flex-grow"; backBtn.onclick = () => { playSound('uiClick'); processPlayerInput(t('back_btn')); }; systemButtonsContainer.appendChild(backBtn); }
        const pauseBtn = document.createElement('button'); pauseBtn.textContent = t('pause_btn'); pauseBtn.className = "button text-cyan-300 border-cyan-300/80 flex-grow"; pauseBtn.onclick = () => { playSound('uiClick'); showPauseMenu(); }; systemButtonsContainer.appendChild(pauseBtn);
        if (systemButtonsContainer.hasChildNodes()) { UI.dialogueOptionsContainer.appendChild(systemButtonsContainer); }

        if (node.responses) { 
            for (const key in node.responses) { 
                const responseNode = node.responses[key];
                const button = document.createElement('button'); 
                button.textContent = t(responseNode.text_key); 
                button.className = "button w-full sm:w-[calc(50%-0.25rem)]"; 
                button.onclick = () => { playSound('uiClick'); processPlayerInput(t(responseNode.text_key)); };
                UI.dialogueOptionsContainer.appendChild(button); 
            } 
        }
    }
    
    async function displayChatbotResponse(messageKey, args = {}) {
       if (!messageKey) { renderDialogueOptions(); return; }
       const tone = GameState.temporaryTone || GameState.chatbotTone; 
       const color = tone === 'Friendly' ? 'var(--main-color)' : tone === 'Ambiguous' ? '#ffdb58' : tone === 'Sinister' ? '#ff474c' : '#c500ff';
       const defaultArgs = { playerName: GameState.playerName, playerBackstory: t('backstory_title_' + GameState.playerBackstory.replace(/ /g, '_')) };
       const formattedMessage = t(messageKey, {...defaultArgs, ...args});
       await typeWriter(UI.gameOutput, `SYNAPSE: ${formattedMessage}`, color); 
       addToConversationHistory(`SYNAPSE: ${formattedMessage}`);
    }

    function handleMove(direction) {
        const room = rooms[GameState.currentRoom]; if (!room) return;
        const langDirections = directionMap[currentLanguage] || directionMap['en'];
        const mappedDirection = langDirections[direction.toLowerCase()] || Object.keys(room.exits).find(d => d.toLowerCase() === direction.toLowerCase());

        if (mappedDirection && room.exits[mappedDirection]) {
            const nextRoomName = room.exits[mappedDirection];
            const nextRoom = rooms[nextRoomName];
            if (nextRoom.isSealed) {
                typeWriter(UI.gameOutput, t('door_is_sealed'), '#ff474c');
                playSound('sanityLoss');
            } else if (nextRoom.requiresKeycard && !hasItem(nextRoom.keyName || 'keycard')) {
                typeWriter(UI.gameOutput, t('door_is_locked'), '#ff474c');
                playSound('sanityLoss');
            } else {
                GameState.currentRoom = nextRoomName;
                playSound('doorOpen');
                renderRoom();
            }
        } else {
            typeWriter(UI.gameOutput, t('cannot_go_that_way'), '#ff474c');
        }
    }

    function handleTake(itemName) {
        const room = rooms[GameState.currentRoom];
        const itemInRoom = room.objects.find(obj => obj.toLowerCase() === itemName.toLowerCase());
        if (!itemInRoom) {
            typeWriter(UI.gameOutput, t('take_fail_exists', {item: itemName}), '#ff474c');
            return;
        }
        if (!takeableItems.has(itemInRoom)) {
            typeWriter(UI.gameOutput, t('take_fail_takeable', {item: itemName}), '#ff474c');
            return;
        }
        const item = itemData[itemInRoom];
        const currentWeight = GameState.inventory.reduce((sum, i) => sum + i.weight, 0);
        if (currentWeight + item.weight > MAX_INVENTORY_WEIGHT) {
            typeWriter(UI.gameOutput, t('take_fail_weight', {item: itemName}), '#ff474c');
            return;
        }
        GameState.inventory.push(item);
        room.objects = room.objects.filter(obj => obj.toLowerCase() !== itemName.toLowerCase());
        playSound('itemPickup');
        typeWriter(UI.gameOutput, t('take_success', {item: itemName}), '#cccccc');
    }

    function handleUse(itemName) {
        if (!hasItem(itemName)) { typeWriter(UI.gameOutput, t('use_fail_have', {item: itemName}), '#ff474c'); return; }
        if (!usableItems.has(itemName.toLowerCase())) { typeWriter(UI.gameOutput, t('use_fail_usable', {item: itemName}), '#ff474c'); return; }

        let used = false;
        switch (itemName.toLowerCase()) {
            case 'stimpack':
                GameState.sanityLevel = Math.min(GameState.maxSanity, GameState.sanityLevel + 25);
                removeItemFromInventory('stimpack');
                typeWriter(UI.gameOutput, t('use_stimpack'), '#34d399');
                used = true;
                break;
            case 'power cell':
                if (GameState.currentRoom === 'AI Core' && rooms['AI Core'].objects.includes('core console')) {
                    typeWriter(UI.gameOutput, t('use_power_cell'), '#34d399');
                    removeItemFromInventory('power cell');
                    rooms['AI Core'].descriptions[0] = "The AI Core is now online, bathing the room in a brilliant, stable light. The central sphere pulses with a steady, powerful rhythm.";
                    GameState.flags.aiRebooted = true; // Condition for an ending
                    used = true;
                } else { typeWriter(UI.gameOutput, t('use_power_cell_fail'), '#ff474c'); }
                break;
             case 'flashlight': handleToggle(!GameState.flashlightOn, 'flashlight'); used = true; break;
             case 'solvent':
                if (GameState.currentRoom === 'Bio-Lab Access' && rooms['Bio-Lab Access'].isSealed) {
                    rooms['Bio-Lab Access'].isSealed = false;
                    removeItemFromInventory('solvent');
                    typeWriter(UI.gameOutput, t('use_solvent'), '#34d399');
                    used = true;
                } else { typeWriter(UI.gameOutput, t('use_solvent_fail'), '#ff474c'); }
                break;
            case 'dna scanner':
                 if (GameState.currentRoom === 'Specimen Storage' && hasItem('tissue sample')) {
                    typeWriter(UI.gameOutput, t('use_dna_scanner'), '#34d399');
                    if(GameState.playerBackstory === 'medic') {
                        GameState.flags.canSynthesize = true;
                        showGuidance("You have enough data to synthesize a counter-agent. Try combining the scanner with a stimpack.");
                    }
                    used = true;
                } else { typeWriter(UI.gameOutput, t('use_dna_scanner_fail'), '#ff474c'); }
                break;
        }
        if(used && itemName.toLowerCase() !== 'flashlight') { playSound('itemPickup'); typeWriter(UI.gameOutput, t('use_success', {item: itemName}), '#cccccc'); }
    }

    function handleExamine(targetName) {
        const itemInInventory = GameState.inventory.find(i => i.name.toLowerCase() === targetName.toLowerCase());
        const itemInRoom = rooms[GameState.currentRoom].objects.find(o => o.toLowerCase() === targetName.toLowerCase());
        const targetItem = itemInInventory ? itemData[itemInInventory.name] : itemInRoom ? itemData[itemInRoom] : null;

        if (targetItem) {
            const desc = targetItem.description[currentLanguage] || targetItem.description['en'];
            typeWriter(UI.gameOutput, `[Examine] ${desc}`);
        } else if (itemInRoom) {
             typeWriter(UI.gameOutput, t('examine_fail_no_desc', { item: targetName }));
        } else {
            typeWriter(UI.gameOutput, t('examine_fail_exists', { item: targetName }), '#ff474c');
        }
    }

    function handleCombine(argument) {
        const parts = argument.split(' with ');
        if(parts.length !== 2) { typeWriter(UI.gameOutput, t('invalid_combine_format'), '#ff474c'); return; }
        const item1Name = parts[0].trim();
        const item2Name = parts[1].trim();
        if (!hasItem(item1Name) || !hasItem(item2Name)) { typeWriter(UI.gameOutput, t('combine_fail_have'), '#ff474c'); return; }
        const recipeKey1 = `${item1Name}-${item2Name}`;
        const recipeKey2 = `${item2Name}-${item1Name}`;
        const recipe = recipes[recipeKey1] || recipes[recipeKey2];
        if (!recipe) { typeWriter(UI.gameOutput, t('combine_fail_recipe'), '#ff474c'); return; }
        removeItemFromInventory(item1Name);
        removeItemFromInventory(item2Name);
        GameState.inventory.push({ name: recipe.result, ...recipe });
        typeWriter(UI.gameOutput, t('combine_success', { item: recipe.result }), '#34d399');
    }

    function handleRest() {
        if (safeRooms.has(GameState.currentRoom)) {
            if (GameState.turnCount > GameState.lastRestTurn + 3) {
                GameState.lastRestTurn = GameState.turnCount;
                GameState.sanityLevel = Math.min(GameState.maxSanity, GameState.sanityLevel + 15);
                typeWriter(UI.gameOutput, t('rest_safe'), '#34d399');
            } else { typeWriter(UI.gameOutput, t('rest_too_soon'), '#ffdb58'); }
        } else { 
            typeWriter(UI.gameOutput, t('rest_unsafe'), '#ff474c');
            GameState.events.triedUnsafeRest = true;
            playSound('sanityLoss'); 
        }
    }

    function handleDrop(itemName) {
        if (!hasItem(itemName)) { typeWriter(UI.gameOutput, t('drop_fail_have', {item: itemName}), '#ff474c'); return; }
        const item = GameState.inventory.find(i => i.name.toLowerCase() === itemName.toLowerCase());
        removeItemFromInventory(itemName);
        rooms[GameState.currentRoom].objects.push(item.name);
        GameState.roomsWithDroppedItems.add(GameState.currentRoom);
        typeWriter(UI.gameOutput, t('drop_success', {item: itemName}), '#cccccc');
    }

    function handleShout() {
        GameState.events.shouted = true;
        playSound('sanityLoss'); 
        typeWriter(UI.gameOutput, t('shout_response'))
    }
    
    function handleTalk() { buildDialogueTree(GameState.chatbotTone); displayChatbotResponse(GameState.dialogue.currentNode.message_key).then(() => { renderDialogueOptions(); }); }

    function handleRead(targetName) {
        const itemInInventory = GameState.inventory.find(i => i.name.toLowerCase() === targetName.toLowerCase());
        const itemInRoom = rooms[GameState.currentRoom].objects.find(o => o.toLowerCase() === targetName.toLowerCase());
        const targetItemName = itemInInventory ? itemInInventory.name : itemInRoom;
        if (!targetItemName) { typeWriter(UI.gameOutput, t('read_fail_exists'), '#ff474c'); return; }
        if (readableItems.has(targetItemName)) {
            const desc = itemData[targetItemName].description[currentLanguage] || itemData[targetItemName].description['en'];
            typeWriter(UI.gameOutput, `[Read] ${desc}`);
            if(targetItemName === 'firewalled data log') GameState.flags.truthExposed = true;
        } else { typeWriter(UI.gameOutput, t('read_fail_readable'), '#ff474c'); }
    }

    function handleSearch(targetName) {
        const room = rooms[GameState.currentRoom];
        const searchable = searchableObjects[targetName];
        if (room.objects.includes(targetName) && searchable && !room.states?.[`${targetName}_searched`]) {
            typeWriter(UI.gameOutput, searchable[currentLanguage] || searchable['en']);
            if (searchable.item) { room.objects.push(searchable.item); showGuidance(t('hint_take', {item: searchable.item}));}
            if(!room.states) room.states = {};
            room.states[`${targetName}_searched`] = true;
        } else { typeWriter(UI.gameOutput, t('nothing_happens')); }
    }
    
    function handleListen() {
        const room = rooms[GameState.currentRoom];
        let listenDesc = t('listen_default');
        if (room.name === 'Specimen Storage') { listenDesc = "Beneath the hum of machinery, you can hear a soft, wet, rhythmic pulsing sound. It seems to be coming from the east."; }
        typeWriter(UI.gameOutput, listenDesc, '#b19cd9');
    }

    function handleSmell() {
        const room = rooms[GameState.currentRoom];
        let smellDesc = t('smell_default');
        if(room.name === 'Bio-Lab Access' || room.name === 'Specimen Storage') { smellDesc = "The air is thick with the coppery scent of blood and an acrid, chemical odor like formaldehyde."; }
        typeWriter(UI.gameOutput, smellDesc, '#b19cd9');
    }

    function handleToggle(turnOn, itemName) {
        if(itemName.toLowerCase() === 'flashlight') {
            if(!hasItem('flashlight')) { typeWriter(UI.gameOutput, t('use_fail_have', {item: 'flashlight'}), '#ff474c'); return; }
            GameState.flashlightOn = turnOn;
            typeWriter(UI.gameOutput, `[System] Flashlight turned ${turnOn ? 'on' : 'off'}.`, '#cccccc');
            if(GameState.currentRoom === 'Maintenance Tunnel') { renderRoom(); }
        }
    }

    function handleBreak(targetName) {
        const room = rooms[GameState.currentRoom];
        if (!room.breakable || !room.breakable[targetName]) {
            typeWriter(UI.gameOutput, t('break_fail', {item: targetName}), '#ff474c');
            return;
        }
        if (!room.objects.includes(targetName)) {
            typeWriter(UI.gameOutput, t('break_fail_exists', {item: targetName}), '#ff474c');
            return;
        }
        
        const material = room.breakable[targetName];
        room.objects = room.objects.filter(o => o !== targetName);
        delete room.breakable[targetName];
        room.objects.push(`broken ${material}`);
        typeWriter(UI.gameOutput, t('break_success', {item: targetName, material: material}), '#cccccc');
    }

    async function handleHack(targetName) {
        const room = rooms[GameState.currentRoom];
        if (GameState.playerBackstory !== 'hacker') {
            await typeWriter(UI.gameOutput, t('hack_fail_ability'), '#ff474c');
            return;
        }
        if (!room.hackable || !room.hackable.includes(targetName)) {
            await typeWriter(UI.gameOutput, t('hack_fail_target'), '#ff474c');
            return;
        }
        
        await typeWriter(UI.gameOutput, t('hack_start'), '#67e8f9');
        const code = Math.random().toString(36).substring(2, 8).toUpperCase();
        GameState.activeMinigame = {
            type: 'hack',
            code: code,
            prompt: `[HACKING] Enter sequence: ${code}`
        };
        await typeWriter(UI.gameOutput, GameState.activeMinigame.prompt, '#ffdb58');
    }
    
    async function handleMinigameInput(input) {
        const minigame = GameState.activeMinigame;
        if (minigame.type === 'hack') {
            if (input.toUpperCase() === minigame.code) {
                await typeWriter(UI.gameOutput, t('hack_success'), '#34d399');
                const room = rooms[GameState.currentRoom];
                if (!room.states) room.states = {};
                room.states.hacked = true;
                room.objects.push('firewalled data log');
                showGuidance(t('hint_read', {item: 'firewalled data log'}));
            } else {
                await typeWriter(UI.gameOutput, t('hack_failure'), '#ff474c');
                GameState.systemLockdownTurns = 3;
            }
        }
        GameState.activeMinigame = null;
        UI.playerInput.value = '';
        updateUI();
    }

    async function handleAsk(argument) {
        const topic = argument.replace('about', '').trim().toLowerCase();
        let responseKey = 'dlg_ask_default';

        if (topic.includes('chimera')) {
            responseKey = 'dlg_ask_chimera';
            GameState.awarenessLevel += 3;
        }
        
        await displayChatbotResponse(responseKey);
    }
    
    function triggerDynamicEvent() {
        const roll = Math.random();
        if (roll < 0.05) { // 5% chance per turn
            const eventRoll = Math.random();
            if (eventRoll < 0.5) {
                typeWriter(UI.gameOutput, t('event_lights_flicker'), '#ffdb58');
                UI.appContainer.classList.add('flicker');
                setTimeout(() => UI.appContainer.classList.remove('flicker'), 400);
            } else {
                const directions = Object.keys(directionMap['en']);
                const randomDir = directions[Math.floor(Math.random() * directions.length)];
                typeWriter(UI.gameOutput, t('event_noise', {direction: randomDir}), '#ffdb58');
                const pan = (randomDir === 'east' ? 0.8 : randomDir === 'west' ? -0.8 : 0);
                playSound('noiseEvent', { pan: pan });
            }
        }
    }
    
    function updateDynamicMusic() {
        if (!audioInitialized || !GameState.settings.sound.master) return;
        
        const isTense = GameState.awarenessLevel > 50 || GameState.sanityLevel < 40;
        const normalAmbiencePlaying = sounds.ambience.state === 'started';
        const tenseAmbiencePlaying = sounds.ambienceTense.state === 'started';

        if (isTense && !tenseAmbiencePlaying) {
            if (normalAmbiencePlaying) sounds.ambience.stop();
            sounds.ambienceTense.start();
        } else if (!isTense && !normalAmbiencePlaying) {
            if (tenseAmbiencePlaying) sounds.ambienceTense.stop();
            sounds.ambience.start();
        }
    }


    function addJournalEntry(note) { if (!note) return; const entry = `T${GameState.turnCount}: ${note}`; GameState.journalEntries.push(entry); updateUI(); }
    function displayJournal() { if (window.innerWidth < 768) showStatusModal(); else typeWriter(UI.gameOutput, "[System] Journal entries displayed on the right panel.", '#cccccc'); }
       function displayInventory() { if (window.innerWidth < 768) showStatusModal(); else typeWriter(UI.gameOutput, "[System] Inventory displayed on the right panel.", '#cccccc'); }
    function displayObjectives() { if (window.innerWidth < 768) showStatusModal(); else typeWriter(UI.gameOutput, "[System] Current objectives displayed on the right panel.", '#cccccc'); }
    function displayMap() { if (window.innerWidth < 768) showStatusModal(); else typeWriter(UI.gameOutput, "[System] Map is displayed on the right panel.", '#cccccc'); }
    function showExits() { typeWriter(UI.gameOutput, `[System] Exits: ${Object.keys(rooms[GameState.currentRoom].exits).join(', ')}`); }


    function saveStateSnapshot() { if(stateSnapshots.length > 20) stateSnapshots.shift(); stateSnapshots.push(JSON.parse(JSON.stringify(GameState, (key, value) => value instanceof Set ? [...value] : value))); }
    function addToConversationHistory(line) { if(GameState.conversationHistory.length > 50) GameState.conversationHistory.shift(); GameState.conversationHistory.push(line); }
    
    function saveGame(isAutosave = false) {
        try { 
            saveSettings();
            const saveData = JSON.stringify(GameState, (key, value) => value instanceof Set ? [...value] : value); 
            localStorage.setItem('synapse_savegame_v15', saveData); 
            if (!isAutosave) typeWriter(UI.gameOutput, t('game_saved'), '#cccccc'); 
            else GameState.systemLogs.push(`[${new Date().toISOString()}] ${t('autosave_success')}.`); 
        } catch(e) { 
            console.error("Save failed:", e); 
        }
    }
    
    function loadGame() {
        const savedData = localStorage.getItem('synapse_savegame_v15');
        if (savedData) {
            try {
                const loadedState = JSON.parse(savedData);
                resetGameState(); 
                Object.assign(GameState, loadedState);
                GameState.settings = loadSettings();
                applySettings();
                GameState.visitedRooms = new Set(loadedState.visitedRooms);
                GameState.dialogue.askedQuestions = new Set(loadedState.dialogue.askedQuestions || []);
                GameState.roomsWithDroppedItems = new Set(loadedState.roomsWithDroppedItems || []);
                GameState.achievements = loadedState.achievements || [];
                GameState.unlockedEndings = loadedState.unlockedEndings || {};
                initializeData(); 
                buildDialogueTree(GameState.chatbotTone);
                GameState.dialogue.currentNode = GameState.dialogue.cache[GameState.chatbotTone]; GameState.dialogue.previousNodes = [];
                UI.startScreen.classList.add('hidden'); 
                UI.playerSetup.classList.add('hidden');
                UI.gameScreen.classList.remove('hidden'); 
                UI.gameScreen.classList.add('flex');
                UI.gameOutput.innerHTML = ''; 
                typeWriter(UI.gameOutput, t('game_loaded'), '#cccccc');
                renderRoom(); 
                updateUI(); 
                renderDialogueOptions();
            } catch(e) { console.error("Load failed:", e); showModal(t('load_fail')); }
        } else { showModal(t('no_save')); }
    }

    function showModal(content, isHtml = false) {
        if(isHtml) { UI.modalContent.innerHTML = content; } else { UI.modalContent.textContent = content; }
        UI.modal.classList.remove('hidden'); UI.modal.classList.add('flex');
        const closeModal = () => { playSound('uiClick'); UI.modal.classList.add('hidden'); UI.modal.classList.remove('flex'); };
        UI.modal.onclick = (e) => { if (e.target === UI.modal) { closeModal(); } };
        const closeBtn = UI.modalContent.querySelector('.close-modal-btn'); if (closeBtn) { closeBtn.onclick = closeModal; }
    }
    
    function hideModal() { UI.modal.classList.add('hidden'); UI.modal.classList.remove('flex'); }

    function showBackstoryModal() {
        let content = `<h2 class="text-2xl mb-4 title-font text-cyan-400">${t('choose_backstory_title')}</h2>
                       <div class="modal-scroll flex-grow p-2">
                           <p class="text-gray-400 text-sm mb-4">${t('choose_backstory_desc')}</p>
                           <div id="backstory-list" class="text-left space-y-2">`;
        for (const key in backstories) {
            const backstoryTitleKey = 'backstory_title_' + key.replace(/ /g, '_');
            const displayName = t(backstoryTitleKey);
            content += `<button class="backstory-choice-btn button w-full text-left !justify-start !p-3" data-backstory="${key}">
                            <div><strong class="text-green-300">${displayName}</strong>: <span class="text-gray-300 text-sm">${t(backstories[key].description_key)}</span></div>
                        </button>`;
        }
        content += `</div></div><button class="close-modal-btn button mt-6">${t('close_btn')}</button>`;
        showModal(content, true);
        document.getElementById('backstory-list').addEventListener('click', (e) => {
            const button = e.target.closest('.backstory-choice-btn');
            if (button) {
                playSound('uiClick');
                UI.playerBackstoryInput.value = button.dataset.backstory;
                updateAbilityDisplay();
                hideModal();
            }
        });
    }

    function showFeaturesModal() {
        let featuresHtml = `<h2 class="text-2xl mb-4 title-font text-cyan-400">${t('features_title')}</h2>
        <div class="modal-scroll text-left p-2 text-sm flex-grow">
            
            <h3 class="text-lg font-bold mt-4 mb-2 text-white">${t('features_core_mechanics_title')}</h3>
            <ul class="list-disc pl-5 space-y-3 text-gray-300">
                <li><strong>${t('features_stats_system')}</strong>
                    <ul class="list-circle pl-5 mt-1 space-y-1">
                        <li><strong class="text-cyan-400">${t('sanity')}:</strong> ${t('features_sanity_desc')}</li>
                        <li><strong class="text-cyan-400">${t('awareness')}:</strong> ${t('features_awareness_desc')}</li>
                    </ul>
                </li>
                <li><strong>${t('features_turn_based_title')}</strong> ${t('features_turn_based_desc')}</li>
                <li><strong>${t('features_dynamic_ai_title')}</strong> ${t('features_dynamic_ai_desc')}</li>
            </ul>

            <h3 class="text-lg font-bold mt-4 mb-2 text-white">${t('features_player_and_char_title')}</h3>
            <ul class="list-disc pl-5 space-y-2 text-gray-300">
                <li>${t('features_character_creation_desc')}</li>
                <li>${t('features_journal_desc')}</li>
                <li>${t('features_objectives_desc')}</li>
            </ul>

            <h3 class="text-lg font-bold mt-4 mb-2 text-white">${t('features_new_enhancements_title')}</h3>
             <ul class="list-disc pl-5 space-y-3 text-gray-300">
                <li>${t('features_advanced_commands_desc')}</li>
                <li>${t('features_dynamic_events_desc')}</li>
                <li>${t('features_deeper_lore_desc')}</li>
            </ul>

            <h3 class="text-lg font-bold mt-4 mb-2 text-white">${t('features_new_ui_ux_title')}</h3>
             <ul class="list-disc pl-5 space-y-3 text-gray-300">
                <li>${t('features_clickable_objects_desc')}</li>
                <li>${t('features_autocomplete_desc')}</li>
                <li>${t('features_audio_desc')}</li>
            </ul>

             <h3 class="text-lg font-bold mt-4 mb-2 text-white">${t('features_player_commands_title')}</h3>
            <ul class="list-disc pl-5 space-y-2 text-gray-300">
                 <li>${t('features_commands_nav')}</li>
                 <li>${t('features_commands_interact')}</li>
                 <li>${t('features_commands_info')}</li>
                 <li>${t('features_commands_sys')}</li>
            </ul>
        </div>
        <button class="close-modal-btn button mt-6">${t('close_btn')}</button>`;
        showModal(featuresHtml, true);
    }

    function showHelpMenu() {
        const helpText = `<h2 class="text-2xl mb-4 title-font text-cyan-400">${t('help')}</h2>
        <div class="modal-scroll text-left p-2 text-sm flex-grow">
            <p class="mb-4">Type commands to interact. Most commands advance the turn counter.</p>
            <div>
                <h3 class="text-lg font-bold text-white">${t('features_commands_nav')}</h3>
                <p class="text-gray-300"><strong class="text-yellow-400">go [direction]</strong> - Move north, south, east, or west.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">look around</strong> - Describe the current room and visible items.</p>
            </div>
            <div class="mt-4">
                <h3 class="text-lg font-bold text-white">${t('features_commands_interact')}</h3>
                <p class="text-gray-300"><strong class="text-yellow-400">take [item]</strong> - Pick up an item from the room.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">use [item]</strong> - Use an item from your inventory.</p>
                 <p class="text-gray-300"><strong class="text-yellow-400">drop [item]</strong> - Drop an item in the current room.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">examine [item/object]</strong> - Get a detailed description of something.</p>
                 <p class="text-gray-300"><strong class="text-yellow-400">read [item/object]</strong> - Read text from an object.</p>
                 <p class="text-gray-300"><strong class="text-yellow-400">search [object]</strong> - Search an object for hidden items.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">combine [item1] with [item2]</strong> - Try to combine two items in your inventory.</p>
                 <p class="text-gray-300"><strong class="text-yellow-400">listen</strong> / <strong class="text-yellow-400">smell</strong> - Use your senses.</p>
                 <p class="text-gray-300"><strong class="text-yellow-400">break [object]</strong> - Attempt to break an object in the room.</p>
                 <p class="text-gray-300"><strong class="text-yellow-400">hack [object]</strong> - Attempt to hack a terminal (Hacker only).</p>
                 <p class="text-gray-300"><strong class="text-yellow-400">ask about [topic]</strong> - Ask SYNAPSE about a specific topic.</p>
            </div>
             <div class="mt-4">
                <h3 class="text-lg font-bold text-white">${t('features_commands_info')}</h3>
                <p class="text-gray-300"><strong class="text-yellow-400">inventory</strong> / <strong class="text-yellow-400">objectives</strong> / <strong class="text-yellow-400">journal</strong> - View status panels (or modal on mobile).</p>
                 <p class="text-gray-300"><strong class="text-yellow-400">journal add [note]</strong> - Add a custom note to your journal.</p>
                 <p class="text-gray-300"><strong class="text-yellow-400">history</strong> - View your last 20 commands.</p>
            </div>
            <div class="mt-4">
                <h3 class="text-lg font-bold text-white">${t('features_commands_sys')}</h3>
                <p class="text-gray-300"><strong class="text-yellow-400">save / load</strong> - Save or load your game progress.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">rest</strong> - Attempt to rest and recover sanity in safe rooms.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">quit / exit</strong> - End the game and return to the main menu.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">cls / clear</strong> - Clear the output screen.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">undo</strong> - Revert your last action.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">again / a</strong> - Repeat your last command.</p>
                <p class="text-gray-300"><strong class="text-yellow-400">wait</strong> - Pass a turn.</p>
            </div>
        </div>
        <button class="close-modal-btn button mt-6">${t('close_btn')}</button>`;
        showModal(helpText, true);
    }
    
    function showStatusModal() {
        const currentWeight = GameState.inventory.reduce((sum, item) => sum + (item?.weight || 1), 0);
        const statusText = `
        <h2 class="text-2xl mb-4 title-font text-cyan-400">${t('status_btn')}</h2>
        <div class="modal-scroll text-left p-2 text-sm flex-grow">
            <!-- Stats -->
            <div id="modal-stats-panel" class="mb-4">
                <h3 class="font-bold border-b border-[var(--main-color-border)] mb-2">${t('stats_title')}</h3>
                <div>${GameState.playerName} (${t('backstory_title_' + GameState.playerBackstory.replace(/ /g, '_'))})</div>
                <div><span data-lang="awareness">${t('awareness')}</span>: ${GameState.awarenessLevel}</div>
                <div><span data-lang="sanity">${t('sanity')}</span>: ${GameState.sanityLevel}</div>
                <div><span data-lang="tone">${t('tone')}</span>: ${GameState.temporaryTone || GameState.chatbotTone}</div>
                <div><span data-lang="turn">${t('turn')}</span>: ${GameState.turnCount}</div>
            </div>
            <!-- Inventory -->
            <div id="modal-inventory-panel" class="mb-4">
                <h3 class="font-bold border-b border-[var(--main-color-border)] mb-2">${t('inventory_title')} (${currentWeight}/${MAX_INVENTORY_WEIGHT})</h3>
                <ul class="list-none p-0">${GameState.inventory.length > 0 ? GameState.inventory.map(item => `<li>- ${item.name}</li>`).join('') : `<li>${t('empty_inventory')}</li>`}</ul>
            </div>
            <!-- Objectives -->
            <div id="modal-objectives-panel" class="mb-4">
                 <h3 class="font-bold border-b border-[var(--main-color-border)] mb-2">${t('objectives_title')}</h3>
                 <ul class="list-none p-0 text-sm">${GameState.objectives.length > 0 ? GameState.objectives.map(obj => `<li>${obj.completed ? `<span class="text-gray-500 line-through">${obj.text}</span>` : `&gt; ${obj.text}`}</li>`).join('') : `<li>${t('no_objectives')}</li>`}</ul>
            </div>
             <!-- Journal -->
            <div id="modal-journal-panel" class="mb-4">
                 <h3 class="font-bold border-b border-[var(--main-color-border)] mb-2">${t('journal_title')}</h3>
                 <ul class="list-none p-0 text-sm">${GameState.journalEntries.slice().reverse().map(entry => `<li>${entry}</li>`).join('')}</ul>
            </div>
        </div>
        <button class="close-modal-btn button mt-6">${t('close_btn')}</button>`;
        showModal(statusText, true);
    }
    
    function showProgressionModal() {
        const unlockedEndings = JSON.parse(localStorage.getItem(ENDINGS_STORAGE_KEY) || '{}');
        const unlockedAchievements = JSON.parse(localStorage.getItem(ACHIEVEMENTS_STORAGE_KEY) || '{}');

        let endingsHtml = `<h4 class="text-md font-bold mt-4 mb-2 text-white">${t('unlocked_endings')}</h4>`;
        const endingsList = Object.values(unlockedEndings);
        if(endingsList.length > 0) {
            endingsHtml += `<ul class="list-disc pl-5 text-gray-300">${endingsList.map(e => `<li><strong>${e.title}</strong>: ${e.desc}</li>`).join('')}</ul>`;
        } else {
            endingsHtml += `<p class="text-gray-400">${t('no_endings')}</p>`;
        }
        
        let achievementsHtml = '';

        const progressionText = `
        <h2 class="text-2xl mb-4 title-font text-cyan-400">${t('progress_btn')}</h2>
        <div class="modal-scroll flex-grow p-2 text-left">
            ${endingsHtml}
            ${achievementsHtml}
        </div>
        <button class="close-modal-btn button mt-6">${t('close_btn')}</button>`;
        showModal(progressionText, true);
    }

    function showPauseMenu() {
        const pauseText = `<h2 class="text-2xl mb-4 title-font text-cyan-400">${t('pause_title')}</h2>
        <div class="modal-scroll flex-grow pr-2">
            <div class="flex flex-col gap-2">
                <button id="pause-achievements" class="button">${t('achievements_btn')}</button>
                <button id="pause-endings" class="button">${t('endings_btn')}</button>
                <hr class="border-gray-700 my-2">
                <button id="pause-features" class="button">${t('understand_game')}</button>
                <button id="pause-help" class="button">${t('help')}</button>
                <button id="pause-settings" class="button">${t('settings_btn')}</button>
                <button id="pause-lang" class="button">${t('lang_switch_btn')}</button>
                <hr class="border-gray-700 my-2">
                <button id="pause-save" class="button">${t('save_game')}</button>
                <button id="pause-load" class="button">${t('load_game')}</button>
                <button id="pause-main-menu" class="button text-yellow-300 border-yellow-300/80">${t('main_menu_btn')}</button>
                <button id="pause-resume" class="button button-primary mt-4">${t('resume_btn')}</button>
            </div>
        </div>`; 
        showModal(pauseText, true); 
        document.getElementById('pause-save').onclick = () => { playSound('uiClick'); saveGame(); hideModal(); }; 
        document.getElementById('pause-load').onclick = () => { playSound('uiClick'); loadGame(); hideModal(); }; 
        document.getElementById('pause-settings').onclick = () => { playSound('uiClick'); showSettingsModal(true); };
        document.getElementById('pause-help').onclick = () => { playSound('uiClick'); showHelpMenu(); }; 
        document.getElementById('pause-features').onclick = () => { playSound('uiClick'); showFeaturesModal(); }; 
        document.getElementById('pause-main-menu').onclick = () => { playSound('uiClick'); confirmReturnToMainMenu(); };
        document.getElementById('pause-resume').onclick = () => { playSound('uiClick'); hideModal(); };
        document.getElementById('pause-achievements').onclick = () => { playSound('uiClick'); showAchievementsModal(); };
        document.getElementById('pause-endings').onclick = () => { playSound('uiClick'); showEndingsModal(); };
        document.getElementById('pause-lang').onclick = () => { 
            playSound('uiClick');
            setLanguage(currentLanguage === 'en' ? 'sv' : 'en');
            showPauseMenu(); // Re-render the pause menu with the new language
        };
    }

    function showAchievementsModal() {
        let content = `<h2 class="text-2xl mb-4 title-font text-cyan-400">${t('achievements_title')}</h2>
                       <div class="modal-scroll flex-grow p-2 text-left">`;
        
        const unlockedAchievements = GameState.achievements || [];

        content += `<h3 class="text-lg font-bold mb-2 text-white">${t('unlocked_achievements')}</h3>`;
        if (unlockedAchievements.length > 0) {
            content += `<ul class="list-disc pl-5 space-y-2">`;
            unlockedAchievements.forEach(id => {
                const ach = achievements[id];
                content += `<li class="text-green-300"><strong>${t(ach.title_key)}:</strong> <span class="text-gray-300">${t(ach.req_key)}</span></li>`;
            });
            content += `</ul>`;
        } else {
            content += `<p class="text-gray-400">${t('no_achievements')}</p>`;
        }

        content += `<h3 class="text-lg font-bold mt-4 mb-2 text-white">${t('locked_achievement')}</h3>`;
        content += `<ul class="list-disc pl-5 space-y-2">`;
        let lockedCount = 0;
        for (const id in achievements) {
            if (!unlockedAchievements.includes(id)) {
                lockedCount++;
                const ach = achievements[id];
                content += `<li class="text-gray-500"><strong>????:</strong> <span class="text-gray-600 italic">Undiscovered</span></li>`;
            }
        }
         if (lockedCount === 0) {
            content += `<p class="text-green-400">All achievements unlocked!</p>`;
        }
        content += `</ul>`;

        content += `</div><button class="close-modal-btn button mt-6">${t('back_btn')}</button>`;
        showModal(content, true);
        const closeBtn = UI.modalContent.querySelector('.close-modal-btn');
        if(closeBtn) {
            closeBtn.onclick = () => {
                playSound('uiClick');
                showPauseMenu();
            };
        }
    }

    function showEndingsModal() {
        let content = `<h2 class="text-2xl mb-4 title-font text-cyan-400">${t('endings_title')}</h2>
                       <div class="modal-scroll flex-grow p-2 text-left">`;
        
        const unlockedEndings = GameState.unlockedEndings || {};
        const unlockedKeys = Object.keys(unlockedEndings);

        content += `<h3 class="text-lg font-bold mb-2 text-white">${t('unlocked_endings')}</h3>`;

        if (unlockedKeys.length > 0) {
            content += `<ul class="list-disc pl-5 space-y-3">`;
            unlockedKeys.forEach(key => {
                const ending = endings[key];
                content += `<li class="text-green-300">
                    <strong>${t(ending.title_key)}:</strong>
                    <p class="text-gray-300 text-sm">${t(ending.desc_key)}</p>
                </li>`;
            });
            content += `</ul>`;
        } else {
             content += `<p class="text-gray-400">${t('no_endings')}</p>`;
        }

        const lockedCount = Object.keys(endings).length - unlockedKeys.length;
        if (lockedCount > 0) {
            content += `<h3 class="text-lg font-bold mt-4 mb-2 text-white">Locked Endings</h3>`;
            content += `<p class="text-gray-500">${lockedCount} ending(s) remain undiscovered.</p>`;
        }


        content += `</div><button class="close-modal-btn button mt-6">${t('back_btn')}</button>`;
        showModal(content, true);
        const closeBtn = UI.modalContent.querySelector('.close-modal-btn');
        if(closeBtn) {
            closeBtn.onclick = () => {
                playSound('uiClick');
                showPauseMenu();
            };
        }
    }


    function showSettingsModal(fromPauseMenu = false) {
        const { settings } = GameState;
        const settingsText = `<h2 class="text-2xl mb-4 title-font text-cyan-400">${t('settings_title')}</h2>
        <div class="modal-scroll text-left p-2 text-sm flex-grow space-y-4">
            
            <div class="flex items-center justify-between">
                <span data-lang="setting_ui_theme">${t('setting_ui_theme')}</span>
                <div class="flex gap-2">
                    <button id="theme-green" class="button text-xs ${settings.theme === 'green' ? 'button-primary' : ''}">${t('theme_green')}</button>
                    <button id="theme-amber" class="button text-xs ${settings.theme === 'amber' ? 'button-primary' : ''}">${t('theme_amber')}</button>
                    <button id="theme-blue" class="button text-xs ${settings.theme === 'blue' ? 'button-primary' : ''}">${t('theme_blue')}</button>
                </div>
            </div>

             <div class="flex items-center justify-between">
                <span data-lang="setting_font_family">${t('setting_font_family')}</span>
                <div class="flex gap-2">
                    <button id="font-space" class="button text-xs ${settings.font === 'Space Mono' ? 'button-primary' : ''}">Space Mono</button>
                    <button id="font-courier" class="button text-xs ${settings.font === 'Courier Prime' ? 'button-primary' : ''}">Courier</button>
                </div>
            </div>

            <div class="flex items-center justify-between">
                <span data-lang="setting_text_speed">${t('setting_text_speed')}</span>
                <div class="flex gap-2">
                    <button id="speed-fast" class="button text-xs ${settings.textSpeed === TextSpeed.Fast ? 'button-primary' : ''}">${t('fast')}</button>
                    <button id="speed-normal" class="button text-xs ${settings.textSpeed === TextSpeed.Normal ? 'button-primary' : ''}">${t('normal')}</button>
                    <button id="speed-slow" class="button text-xs ${settings.textSpeed === TextSpeed.Slow ? 'button-primary' : ''}">${t('slow')}</button>
                </div>
            </div>

            <div class="flex items-center justify-between">
                <span data-lang="setting_crt_effect">CRT Effect</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-crt" ${settings.glitchEffect ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="flex items-center justify-between">
                <span data-lang="setting_colorblind_mode">${t('setting_colorblind_mode')}</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-colorblind" ${settings.colorblindMode ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
            </div>

            <hr class="border-gray-700 my-4">

            <div class="flex items-center justify-between">
                <span data-lang="setting_master_volume">${t('setting_master_volume')}</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-master" ${settings.sound.master ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
            </div>
             <div class="flex items-center justify-between">
                <span data-lang="setting_item_found">${t('setting_item_found')}</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-item" ${settings.sound.item ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="flex items-center justify-between">
                <span data-lang="setting_high_awareness">${t('setting_high_awareness')}</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-awareness" ${settings.sound.awareness ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
            </div>
            <div class="flex items-center justify-between">
                <span data-lang="setting_low_sanity">${t('setting_low_sanity')}</span>
                <label class="toggle-switch">
                    <input type="checkbox" id="setting-sanity" ${settings.sound.sanity ? 'checked' : ''}>
                    <span class="slider"></span>
                </label>
            </div>
            
            <hr class="border-gray-700 my-4">
            
            <button id="reset-settings-btn" class="button w-full text-yellow-300 border-yellow-300/80">${t('setting_reset_defaults')}</button>
        </div>
        <button class="close-modal-btn button mt-6">${t('close_btn')}</button>`;
        showModal(settingsText, true);

        const setupToggle = (id, obj, key) => {
            const el = document.getElementById(id);
            if(el) {
                el.onchange = (e) => {
                    obj[key] = e.target.checked;
                    saveSettings();
                    applySettings();
                };
            }
        };
        
        setupToggle('setting-master', GameState.settings.sound, 'master');
        setupToggle('setting-item', GameState.settings.sound, 'item');
        setupToggle('setting-awareness', GameState.settings.sound, 'awareness');
        setupToggle('setting-sanity', GameState.settings.sound, 'sanity');
        setupToggle('setting-colorblind', GameState.settings, 'colorblindMode');
        setupToggle('setting-crt', GameState.settings, 'glitchEffect');

        const setupButtonGroup = (buttons, key, valueMap) => {
            buttons.forEach(id => {
                const btn = document.getElementById(id);
                if(btn) {
                    btn.addEventListener('click', () => {
                        GameState.settings[key] = valueMap[id];
                        document.querySelectorAll(buttons.map(b => `#${b}`).join(', ')).forEach(b => b.classList.remove('button-primary'));
                        btn.classList.add('button-primary');
                        saveSettings();
                        applySettings();
                    });
                }
            });
        };

        setupButtonGroup(['speed-fast', 'speed-normal', 'speed-slow'], 'textSpeed', {'speed-fast': TextSpeed.Fast, 'speed-normal': TextSpeed.Normal, 'speed-slow': TextSpeed.Slow});
        setupButtonGroup(['theme-green', 'theme-amber', 'theme-blue'], 'theme', {'theme-green': 'green', 'theme-amber': 'amber', 'theme-blue': 'blue'});
        setupButtonGroup(['font-space', 'font-courier'], 'font', {'font-space': 'Space Mono', 'font-courier': 'Courier Prime'});

        const resetBtn = document.getElementById('reset-settings-btn');
        if(resetBtn) {
            resetBtn.onclick = () => {
                GameState.settings = {
                    sound: { master: true, item: true, awareness: true, sanity: true },
                    textSpeed: TextSpeed.Normal,
                    colorblindMode: false,
                    glitchEffect: true,
                    font: 'Space Mono',
                    theme: 'green'
                };
                saveSettings();
                applySettings();
                showSettingsModal(fromPauseMenu);
            };
        }

        const closeBtn = UI.modalContent.querySelector('.close-modal-btn');
        if(closeBtn) {
            closeBtn.onclick = () => {
                playSound('uiClick');
                if (fromPauseMenu) {
                    showPauseMenu();
                } else {
                    hideModal();
                }
            };
        }
    }

    function confirmReturnToMainMenu() {
        const confirmText = `<h2 class="text-xl mb-4 title-font text-yellow-400">${t('confirm_main_menu')}</h2>
        <div class="flex justify-center gap-4">
            <button id="confirm-yes" class="button button-primary">${t('yes')}</button>
            <button id="confirm-no" class="button">${t('no')}</button>
        </div>`;
        showModal(confirmText, true);
        document.getElementById('confirm-yes').onclick = () => { playSound('uiClick'); returnToMainMenu(); };
        document.getElementById('confirm-no').onclick = () => { playSound('uiClick'); showPauseMenu(); };
    }
    
    function returnToMainMenu() {
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
        sessionStorage.removeItem('synapse_session_v15_autosave');
        sessionStorage.removeItem('synapse_session_v15_screen_state');
        GameState.exitGame = true;

        UI.gameScreen.classList.add('hidden'); 
        UI.gameScreen.classList.remove('flex');
        UI.playerSetup.classList.add('hidden');
        UI.playerSetup.classList.remove('flex');

        UI.startScreen.classList.remove('hidden');
        UI.startScreen.classList.add('flex');
        
        UI.gameOutput.innerHTML = '';
        if (audioInitialized && GameState.settings.sound.master) {
            if (sounds.ambience.state === 'started') sounds.ambience.stop();
            if (sounds.ambienceTense.state === 'started') sounds.ambienceTense.stop();
        }
        resetGameState(); 
        setupIntro(); 
        hideModal();
    }


    function setupIntro() { UI.introTextContainer.innerHTML = `<p class="mb-4">${t('intro_1')}</p><p>${t('intro_2')}</p><p>${t('intro_3')}</p>`; }
    
    function startGame() { 
        resetGameState(); initializeData(); saveStateSnapshot(); 
        GameState.playerName = UI.playerNameInput.value || "Subject"; 
        const backstoryKey = (UI.playerBackstoryInput.value || "investigator").toLowerCase();
        GameState.playerBackstory = Object.keys(backstories).includes(backstoryKey) ? backstoryKey : 'investigator';
        GameState.difficulty = Array.from(UI.difficultyBtns).find(b => b.classList.contains('button-primary'))?.dataset.difficulty || Difficulty.Normal; 
        
        UI.startScreen.classList.add('hidden');
        UI.playerSetup.classList.add('hidden');
        UI.gameScreen.classList.remove('hidden'); 
        UI.gameScreen.classList.add('flex'); 

        UI.gameOutput.innerHTML = ''; 
        buildDialogueTree(GameState.chatbotTone);
        if (audioInitialized) updateDynamicMusic();
        
        if (animationFrameId) cancelAnimationFrame(animationFrameId);
        gameLoop();
        
        typeWriter(UI.gameOutput, t('initializing'), '#cccccc').then(() => { 
            showGuidance(t('initial_hint'));
            displayChatbotResponse(GameState.dialogue.currentNode.message_key).then(() => { renderRoom(); updateUI(); renderDialogueOptions(); }); 
        }); 
    }
    
    function checkEndings() {
        if (GameState.exitGame) return;
        for (const key in endings) {
            if (endings[key].check()) {
                endGame(key);
                return; // Important to stop after the first ending is triggered
            }
        }
    }

    function endGame(endingKey) {
        if (GameState.exitGame) return;
        GameState.exitGame = true;
        if(animationFrameId) cancelAnimationFrame(animationFrameId);
        animationFrameId = null;

        const endingData = endings[endingKey];
        if (!endingData) {
            console.error(`Ending with key '${endingKey}' not found.`);
            returnToMainMenu();
            return;
        }

        const endingTitle = t(endingData.title_key);
        const endingDesc = t(endingData.desc_key);

        GameState.unlockedEndings[endingKey] = { title: endingTitle, desc: endingDesc };
        const unlockedEndings = JSON.parse(localStorage.getItem(ENDINGS_STORAGE_KEY) || '{}');
        unlockedEndings[endingKey] = { title: endingTitle, desc: endingDesc };
        localStorage.setItem(ENDINGS_STORAGE_KEY, JSON.stringify(unlockedEndings));

        const endingHtml = `<div class="text-center">
            <h2 class="text-4xl title-font text-red-500 mb-4">${endingTitle}</h2>
            <p class="text-white mb-6">${endingDesc}</p>
            <button id="ending-main-menu" class="button button-primary">${t('main_menu_btn')}</button>
        </div>`;
        showModal(endingHtml, true);
        document.getElementById('ending-main-menu').onclick = () => { playSound('uiClick'); returnToMainMenu(); };
    }

    function checkAchievements() {
        for (const id in achievements) {
            if (!GameState.achievements.includes(id)) {
                if (achievements[id].check()) {
                    unlockAchievement(id);
                }
            }
        }
    }

    function unlockAchievement(id) {
        if (GameState.achievements.includes(id)) return;

        GameState.achievements.push(id);
        const ach = achievements[id];
        playSound('achievement');
        typeWriter(UI.gameOutput, `[${t('achievement_unlocked')}] ${t(ach.title_key)}`, '#FFD700');

        const unlockedAchievements = JSON.parse(localStorage.getItem(ACHIEVEMENTS_STORAGE_KEY) || '{}');
        if (!unlockedAchievements[id]) {
            unlockedAchievements[id] = true;
            localStorage.setItem(ACHIEVEMENTS_STORAGE_KEY, JSON.stringify(unlockedAchievements));
        }
    }


    function hasItem(itemName) { return GameState.inventory.some(i => i.name.toLowerCase() === itemName.toLowerCase()); }
    function removeItemFromInventory(itemName) { const index = GameState.inventory.findIndex(i => i.name.toLowerCase() === itemName.toLowerCase()); if (index > -1) { GameState.inventory.splice(index, 1); } }
    
    function getAbilityDescription(backstoryKey, difficulty) {
        const key = (backstoryKey || "").toLowerCase().trim().replace(/ /g, '_');
        if (!backstories[key]) return t('ability_unknown');
        switch (key) {
            case 'hacker': return t(`ability_hacker_${difficulty.toLowerCase()}`);
            case 'psychologist': return t(`ability_psychologist_${difficulty.toLowerCase()}`);
            case 'technician': return t(`ability_technician_${difficulty.toLowerCase()}`);
            case 'survivor': return difficulty !== Difficulty.Hard ? t('ability_survivor_with_item') : t('ability_survivor');
            case 'skeptic': return difficulty === Difficulty.Easy ? t('ability_skeptic_easy') : t('ability_skeptic_normal');
            case 'corporate_spy': return difficulty !== Difficulty.Hard ? t('ability_spy_with_item') : t('ability_spy');
            case 'medic': return t(`ability_medic_${difficulty.toLowerCase()}`);
            case 'cultist': return difficulty === Difficulty.Hard ? t('ability_cultist_hard') : t('ability_cultist');
            case 'janitor': return difficulty !== Difficulty.Hard ? t('ability_janitor') : t('ability_janitor_hard');
            default: return t('ability_investigator');
        }
    }
    
    function updateAbilityDisplay() { 
        if (!UI.abilityDisplay) return; 
        const difficulty = Array.from(UI.difficultyBtns).find(b => b.classList.contains('button-primary'))?.dataset.difficulty || Difficulty.Normal; 
        const backstoryKey = UI.playerBackstoryInput.value; 
        const description = getAbilityDescription(backstoryKey, difficulty); 
        UI.abilityDisplay.innerHTML = `${t('ability_bonus_prefix')}<span class="text-white">${description}</span>`;
    }

    function startSpeechRecognition() {
        if (!SpeechRecognition) {
            typeWriter(UI.gameOutput, "[SYSTEM] Speech recognition is not supported in your browser.", '#ff474c');
            return;
        }

        recognition.lang = currentLanguage === 'sv' ? 'sv-SE' : 'en-US';

        recognition.onstart = () => {
            UI.micBtn.classList.add('bg-red-500', 'border-red-700');
        };

        recognition.onresult = (event) => {
            let transcript = event.results[0][0].transcript;
            const lowerTranscript = transcript.toLowerCase();
            const langQuestionWords = questionWords[currentLanguage] || questionWords['en'];
            const isQuestion = langQuestionWords.some(word => lowerTranscript.startsWith(word + ' '));

            if (isQuestion && !lowerTranscript.endsWith('?')) {
                transcript += '?';
            }
            
            UI.playerInput.value = transcript;
            setTimeout(() => {
                processPlayerInput(transcript);
            }, 250);
        };

        recognition.onerror = (event) => {
            let errorMsg = `[SYSTEM] Speech recognition error: ${event.error}`;
            if (event.error === 'not-allowed') {
                errorMsg = "[SYSTEM] Microphone access denied. Please allow microphone access in your browser settings.";
            } else if (event.error === 'no-speech') {
                errorMsg = "[SYSTEM] No speech detected. Please try again.";
            }
            typeWriter(UI.gameOutput, errorMsg, '#ff474c');
        };

        recognition.onend = () => {
            UI.micBtn.classList.remove('bg-red-500', 'border-red-700');
        };

        recognition.start();
    }

    async function showGuidance(text) { await typeWriter(UI.gameOutput, `[HINT] ${text}`, GUIDANCE_COLOR); }
    
    function saveStateToSession() {
        if (!UI.gameScreen.classList.contains('hidden') && GameState && typeof GameState.turnCount === 'number' && !GameState.exitGame) {
            try {
                const sessionData = JSON.stringify(GameState, (key, value) => value instanceof Set ? [...value] : value);
                sessionStorage.setItem('synapse_session_v15_autosave', sessionData);
                sessionStorage.removeItem('synapse_session_v15_screen_state');
            } catch (e) {
                console.error("Session game state save failed:", e);
            }
        } 
        else if (!UI.playerSetup.classList.contains('hidden')) {
            try {
                const startState = {
                    isPlayerSetupVisible: true,
                    playerName: UI.playerNameInput.value,
                    playerBackstory: UI.playerBackstoryInput.value,
                    difficulty: Array.from(UI.difficultyBtns).find(b => b.classList.contains('button-primary'))?.dataset.difficulty || Difficulty.Normal,
                    language: currentLanguage
                };
                sessionStorage.setItem('synapse_session_v15_screen_state', JSON.stringify(startState));
                sessionStorage.removeItem('synapse_session_v15_autosave');
            } catch (e) {
                console.error("Session screen state save failed:", e);
            }
        } else {
             sessionStorage.removeItem('synapse_session_v15_autosave');
             sessionStorage.removeItem('synapse_session_v15_screen_state');
        }
    }

    function loadStateFromSession() {
        const sessionData = sessionStorage.getItem('synapse_session_v15_autosave');
        if (!sessionData) return false;
        try {
            const loadedState = JSON.parse(sessionData);
            if (loadedState.currentRoom && typeof loadedState.turnCount === 'number' && !loadedState.exitGame) {
                resetGameState();
                Object.assign(GameState, loadedState);
                GameState.settings = loadSettings();
                applySettings();
                GameState.visitedRooms = new Set(loadedState.visitedRooms || []);
                GameState.dialogue.askedQuestions = new Set(loadedState.dialogue.askedQuestions || []);
                GameState.roomsWithDroppedItems = new Set(loadedState.roomsWithDroppedItems || []);
                GameState.achievements = loadedState.achievements || [];
                GameState.unlockedEndings = loadedState.unlockedEndings || {};
                initializeData(); 
                buildDialogueTree(GameState.chatbotTone);
                GameState.dialogue.currentNode = GameState.dialogue.cache[GameState.chatbotTone] || GameState.dialogue.cache[ChatbotTone.Friendly];
                GameState.dialogue.previousNodes = [];
                UI.startScreen.classList.add('hidden');
                UI.playerSetup.classList.add('hidden');
                UI.gameScreen.classList.remove('hidden');
                UI.gameScreen.classList.add('flex');
                UI.gameOutput.innerHTML = '';
                typeWriter(UI.gameOutput, t('conn_reestablished'), '#cccccc');
                renderRoom();
                updateUI();
                renderDialogueOptions();
                return true;
            }
        } catch (e) {
            console.error("Session load failed:", e);
            sessionStorage.removeItem('synapse_session_v15_autosave');
        }
        return false;
    }
    
    function setupBackgroundAnimation() { 
        const canvas = document.getElementById('background-canvas');
        if (!canvas) return;
        const ctx = canvas.getContext('2d');
        let width, height, particles = [];
        function resize() { width = canvas.width = window.innerWidth; height = canvas.height = window.innerHeight; }
        window.addEventListener('resize', resize);
        resize();
        class Particle { constructor() { this.x = Math.random() * width; this.y = Math.random() * height; this.size = Math.random() * 0.4 + 0.1; this.speedX = (Math.random() * 0.5 - 0.25); this.speedY = (Math.random() * 0.5 - 0.25); } update() { this.x += this.speedX; this.y += this.speedY; if (this.size > 0.1) this.size -= 0.001; if(this.x < 0 || this.x > width) this.speedX *= -1; if(this.y < 0 || this.y > height) this.speedY *= -1; } draw() { ctx.fillStyle = 'var(--main-color)'; ctx.beginPath(); ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2); ctx.fill(); } }
        function initParticles() { particles = []; for(let i=0; i<100; i++) particles.push(new Particle()); }
        function animateParticles() { ctx.clearRect(0,0,width,height); for(let i=0; i<particles.length; i++) { particles[i].update(); particles[i].draw(); if(particles[i].size <= 0.1) { particles.splice(i, 1); i--; particles.push(new Particle()); } } requestAnimationFrame(animateParticles); }
        initParticles(); animateParticles();
    }
    
    function getMapBounds() {
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        Object.values(roomLayout).forEach(r => {
            minX = Math.min(minX, r.x);
            minY = Math.min(minY, r.y);
            maxX = Math.max(maxX, r.x + r.w);
            maxY = Math.max(maxY, r.y + r.h);
        });
        const padding = 20;
        return {minX: minX - padding, minY: minY - padding, maxX: maxX + padding, maxY: maxY + padding};
    }

    function drawMap() {
        if (!UI.mapCanvas) return;
        const canvas = UI.mapCanvas;
        const ctx = canvas.getContext('2d');
        const isFullscreen = UI.mapPanel.classList.contains('fullscreen');
        const dpr = window.devicePixelRatio || 1;
        const rect = canvas.getBoundingClientRect();

        const newWidth = rect.width * dpr;
        const newHeight = rect.height * dpr;

        if (canvas.width !== newWidth || canvas.height !== newHeight) {
            canvas.width = newWidth;
            canvas.height = newHeight;
        }

        ctx.clearRect(0, 0, canvas.width, canvas.height);
        ctx.save();
        ctx.scale(dpr, dpr);

        // Declare playerLayout only once
        const playerLayout = roomLayout[GameState.currentRoom];

        if (isFullscreen) {
            ctx.translate(mapState.offsetX / dpr, mapState.offsetY / dpr);
        } else {
            if (!playerLayout) { ctx.restore(); return; }
            const centerX = playerLayout.x + playerLayout.w / 2;
            const centerY = playerLayout.y + playerLayout.h / 2;
            // Cache rooms to draw for performance
            if (!drawMap._cache) drawMap._cache = { isFullscreen: null, visitedRooms: new Set(), rooms: [] };
            const cache = drawMap._cache;
            let roomsToDraw;
            if (isFullscreen !== cache.isFullscreen ||
                (isFullscreen === false && (GameState.visitedRooms.size !== cache.visitedRooms.size ||
                [...GameState.visitedRooms].some(r => !cache.visitedRooms.has(r))))) {
                if (isFullscreen) {
                    roomsToDraw = Object.keys(roomLayout);
                } else {
                    roomsToDraw = Array.from(GameState.visitedRooms);
                    cache.visitedRooms = new Set(GameState.visitedRooms);
                }
                cache.isFullscreen = isFullscreen;
                cache.rooms = roomsToDraw;
            } else {
                roomsToDraw = cache.rooms;
            }
            const translateX = (rect.width / 2) - (centerX * mapState.scale);
            const translateY = (rect.height / 2) - (centerY * mapState.scale);
            ctx.translate(translateX, translateY);
        }
        ctx.scale(mapState.scale, mapState.scale);
        let roomsToDraw;
        if (isFullscreen) {
            const bounds = getMapBounds();
            const gridSize = 20;
            ctx.strokeStyle = "rgba(0, 255, 65, 0.08)";
            ctx.lineWidth = 0.5 / mapState.scale;

            // Limit the number of grid lines for performance
            const maxGridLines = 100;
            let xLines = Math.ceil((bounds.maxX - bounds.minX) / gridSize);
            let yLines = Math.ceil((bounds.maxY - bounds.minY) / gridSize);
            let xStep = gridSize;
            let yStep = gridSize;
            if (xLines > maxGridLines) xStep = ((bounds.maxX - bounds.minX) / maxGridLines);
            if (yLines > maxGridLines) yStep = ((bounds.maxY - bounds.minY) / maxGridLines);

            for (let x = bounds.minX; x < bounds.maxX; x += xStep) {
                ctx.beginPath(); ctx.moveTo(x, bounds.minY); ctx.lineTo(x, bounds.maxY); ctx.stroke();
            }
            for (let y = bounds.minY; y < bounds.maxY; y += yStep) {
                ctx.beginPath(); ctx.moveTo(bounds.minX, y); ctx.lineTo(bounds.maxX, y); ctx.stroke();
            }

            ctx.strokeStyle = "rgba(0, 255, 65, 0.2)";
            ctx.lineWidth = 1 / mapState.scale;
            Object.keys(roomLayout).forEach(roomName => {
                if (rooms[roomName]?.exits) {
                    const r1Layout = roomLayout[roomName];
                    const r1x = r1Layout.x + r1Layout.w / 2;
                    const r1y = r1Layout.y + r1Layout.h / 2;
                    Object.values(rooms[roomName].exits).forEach(exitName => {
                        const r2Layout = roomLayout[exitName];
                        if (r2Layout) {
                            const r2x = r2Layout.x + r2Layout.w / 2;
                            const r2y = r2Layout.y + r2Layout.h / 2;
                            ctx.beginPath(); ctx.moveTo(r1x, r1y); ctx.lineTo(r2x, r2y); ctx.stroke();
                        }
                    });
                }
            });
            roomsToDraw = Object.keys(roomLayout);
        } else {
            // roomsToDraw is already set in the above else block
            roomsToDraw = roomsToDraw || Array.from(GameState.visitedRooms);
        }
        
        roomsToDraw.forEach(roomName => {
            const layout = roomLayout[roomName];
            if (!layout) return;
            const x = layout.x, y = layout.y, w = layout.w, h = layout.h;
            const isLocked = rooms[roomName].requiresKeycard && !hasItem(rooms[roomName].keyName || 'keycard');
            if (roomName === GameState.currentRoom) {
                const pulseFactor = (Math.sin(Date.now() * 0.005) + 1) / 2;
                ctx.fillStyle = `rgba(0, 255, 65, ${0.5 + pulseFactor * 0.4})`;
                ctx.shadowColor = 'rgba(127, 255, 127, 1)';
                ctx.shadowBlur = (4 + pulseFactor * 8) / mapState.scale;
            } else {
                ctx.fillStyle = "rgba(0, 255, 65, 0.3)";
            }
            ctx.fillRect(x, y, w, h);
            ctx.shadowBlur = 0;

            ctx.strokeStyle = isLocked ? "rgba(255, 71, 76, 0.8)" : "rgba(0, 255, 65, 0.8)";
            ctx.lineWidth = 1.5 / mapState.scale;
            ctx.setLineDash([]);
            ctx.strokeRect(x, y, w, h);

            if (rooms[roomName].objects.length > 0) {
                ctx.fillStyle = "rgba(255, 219, 88, 1)";
                ctx.beginPath();
                ctx.arc(x + w - 5 / mapState.scale, y + 5 / mapState.scale, 2 / mapState.scale, 0, 2 * Math.PI);
                ctx.fill();
            }

            const baseFontSize = 12;
            const fontSize = Math.max(baseFontSize, baseFontSize / mapState.scale);
            ctx.font = `${fontSize}px VT323`;
            ctx.shadowColor = 'rgba(0, 0, 0, 0.9)';
            ctx.shadowBlur = 3 / mapState.scale;
            ctx.shadowOffsetX = 1 / mapState.scale;
            ctx.shadowOffsetY = 1 / mapState.scale;

            ctx.fillStyle = "white";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(layout.name, x + w / 2, y + h / 2 + 1);

            ctx.shadowBlur = 0;
            ctx.shadowOffsetX = 0;
            ctx.shadowOffsetY = 0;

            // Draw outline for unvisited rooms in non-fullscreen mode
            if (!UI.mapPanel.classList.contains('fullscreen') && !GameState.visitedRooms.has(roomName)) {
                ctx.strokeStyle = "rgba(0, 255, 65, 0.25)";
                ctx.lineWidth = 1 / mapState.scale;
                ctx.setLineDash([3 / mapState.scale, 2 / mapState.scale]);
                ctx.strokeRect(x, y, w, h);
                ctx.setLineDash([]);
            }
        });
        
        if (playerLayout) {
             const playerX = playerLayout.x + playerLayout.w / 2;
             const playerY = playerLayout.y + playerLayout.h / 2;
             ctx.fillStyle = "#FF2A7F";
             ctx.beginPath();
             ctx.arc(playerX, playerY, 3 / mapState.scale, 0, 2 * Math.PI);
             ctx.fill();
             ctx.strokeStyle = "white";
             ctx.lineWidth = 0.5 / mapState.scale;
             ctx.stroke();
        }

        ctx.restore();
    }
    
    function toggleMapFullscreen() {
        const isFullscreen = UI.mapPanel.classList.toggle('fullscreen');
        UI.mapExpandIcon.classList.toggle('hidden', isFullscreen);
        UI.mapMinimizeIcon.classList.toggle('hidden', !isFullscreen);
        if (!isFullscreen) {
            mapState.scale = 1;
        }
        setTimeout(() => {
            const playerLayout = roomLayout[GameState.currentRoom];
            if (!playerLayout) return;
            mapState.offsetX = (UI.mapCanvas.width / (window.devicePixelRatio||1) / 2) - (playerLayout.x + playerLayout.w / 2) * mapState.scale;
            mapState.offsetY = (UI.mapCanvas.height / (window.devicePixelRatio||1) / 2) - (playerLayout.y + playerLayout.h / 2) * mapState.scale;
        }, 50);
    }
    
    function initMapControls() {
        const canvas = UI.mapCanvas;
        
        const getEventCoords = (e) => {
            if (e.touches && e.touches.length) {
                return { x: e.touches[0].clientX, y: e.touches[0].clientY };
            }
            return { x: e.clientX, y: e.clientY };
        }

        const handleDragStart = (e) => {
            if (!UI.mapPanel.classList.contains('fullscreen')) return;
            mapState.isDragging = true;
            const coords = getEventCoords(e);
            mapState.lastX = coords.x;
            mapState.lastY = coords.y;
            canvas.style.cursor = 'grabbing';
        };

        const handleDragMove = (e) => {
            if (!mapState.isDragging || !UI.mapPanel.classList.contains('fullscreen')) return;
            e.preventDefault();
            const coords = getEventCoords(e);
            const dX = coords.x - mapState.lastX;
            const dY = coords.y - mapState.lastY;
            mapState.offsetX += dX;
            mapState.offsetY += dY;
            mapState.lastX = coords.x;
            mapState.lastY = coords.y;
        };

        const handleDragEnd = () => {
            mapState.isDragging = false;
            canvas.style.cursor = 'grab';
        };
        
        const handleWheel = (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            const zoomFactor = 1.1;
            const oldScale = mapState.scale;
            let newScale;

            if (e.deltaY < 0) {
                newScale = oldScale * zoomFactor;
            } else {
                newScale = oldScale / zoomFactor;
            }
            newScale = Math.max(0.3, Math.min(newScale, 5));

            if (UI.mapPanel.classList.contains('fullscreen')) {
                mapState.offsetX = mouseX - (mouseX - mapState.offsetX) * (newScale / oldScale);
                mapState.offsetY = mouseY - (mouseY - mapState.offsetY) * (newScale / oldScale);
            }
            mapState.scale = newScale;
        };

        canvas.addEventListener('mousedown', handleDragStart);
        window.addEventListener('mousemove', handleDragMove);
        window.addEventListener('mouseup', handleDragEnd);
        canvas.addEventListener('mouseleave', handleDragEnd);

        canvas.addEventListener('touchstart', handleDragStart, { passive: false });
        window.addEventListener('touchmove', handleDragMove, { passive: false });
        window.addEventListener('touchend', handleDragEnd);
        
        canvas.addEventListener('wheel', handleWheel, { passive: false });
    }
    
    function gameLoop() {
        if (!GameState.exitGame) {
            drawMap();
            animationFrameId = requestAnimationFrame(gameLoop);
        }
    }

    function showHistory() {
        let historyHtml = commandHistory.slice(-20).map((cmd, i) => `<div>${i + 1}: ${cmd}</div>`).join('');
        typeWriter(UI.gameOutput, `--- Command History ---\n${historyHtml}`, '#cccccc');
    }

    function undoLastAction() {
        if (stateSnapshots.length > 1) {
            stateSnapshots.pop(); 
            const prevState = stateSnapshots[stateSnapshots.length - 1];
            GameState = JSON.parse(JSON.stringify(prevState));
            GameState.visitedRooms = new Set(prevState.visitedRooms);
            GameState.dialogue.askedQuestions = new Set(prevState.dialogue.askedQuestions || []);
             GameState.roomsWithDroppedItems = new Set(prevState.roomsWithDroppedItems || []);
            GameState.achievements = prevState.achievements || [];
            updateUI();
            typeWriter(UI.gameOutput, "[System] Last action undone.", "#ffdb58");
        } else {
            typeWriter(UI.gameOutput, "[System] No actions to undo.", "#ff474c");
        }
    }
    
    function toggleDebug() {
        GameState.debugMode = !GameState.debugMode;
        typeWriter(UI.gameOutput, `[System] Debug mode ${GameState.debugMode ? 'enabled' : 'disabled'}.`, '#6495ed');
    }
    
    function toggleColorblind() {
        GameState.settings.colorblindMode = !GameState.settings.colorblindMode;
        saveSettings();
        typeWriter(UI.gameOutput, `[System] Colorblind mode ${GameState.settings.colorblindMode ? 'enabled' : 'disabled'}.`, '#6495ed');
    }

    function updateAutocomplete() {
        const value = UI.playerInput.value.toLowerCase();
        if (!value) {
            UI.autocompleteBox.classList.add('hidden');
            return;
        }

        const allCommands = Object.keys(commandAliases[currentLanguage] || commandAliases['en']);
        const roomObjects = rooms[GameState.currentRoom]?.objects || [];
        const inventoryItems = GameState.inventory.map(i => i.name);
        const allWords = [...new Set([...allCommands, ...roomObjects, ...inventoryItems])];
        
        const suggestions = allWords.filter(w => w.toLowerCase().startsWith(value)).slice(0, 5);

        if (suggestions.length > 0) {
            UI.autocompleteBox.innerHTML = suggestions.map(s => `<div class="autocomplete-item" data-suggestion="${s}">${s}</div>`).join('');
            UI.autocompleteBox.classList.remove('hidden');
        } else {
            UI.autocompleteBox.classList.add('hidden');
        }
    }


    // --- EVENT LISTENERS & INITIALIZATION ---
    window.addEventListener('beforeunload', saveStateToSession);
    window.addEventListener('DOMContentLoaded', () => {
        UI.playerInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') { 
                const input = UI.playerInput.value.trim(); 
                if(input) { processPlayerInput(input); }
            } else if (e.key === 'ArrowUp') { e.preventDefault(); if (commandHistory.length > 0) { commandHistoryIndex = Math.max(0, commandHistoryIndex - 1); UI.playerInput.value = commandHistory[commandHistoryIndex] || ''; }
            } else if (e.key === 'ArrowDown') { e.preventDefault(); if (commandHistory.length > 0) { commandHistoryIndex = Math.min(commandHistory.length, commandHistoryIndex + 1); UI.playerInput.value = commandHistory[commandHistoryIndex] || ''; } }
        });
        
        UI.playerInput.addEventListener('input', updateAutocomplete);
        UI.autocompleteBox.addEventListener('click', (e) => {
            if (e.target.matches('.autocomplete-item')) {
                UI.playerInput.value = e.target.dataset.suggestion;
                UI.autocompleteBox.classList.add('hidden');
                UI.playerInput.focus();
            }
        });

        UI.gameOutput.addEventListener('click', (e) => {
            if (e.target.matches('.clickable-object')) {
                const objectName = e.target.dataset.objectName;
                UI.playerInput.value = `examine ${objectName}`;
                UI.playerInput.focus();
            }
        });

        const setupButtonClick = (button, handler, ...args) => {
            if (!button) return;
            button.addEventListener('click', async () => {
                await initializeAudio();
                playSound('uiClick');
                handler(...args);
            });
        };

        setupButtonClick(UI.newGameBtn, () => { 
            sessionStorage.removeItem('synapse_session_v15_autosave'); 
            sessionStorage.removeItem('synapse_session_v15_screen_state'); 
            UI.startScreen.classList.add('hidden'); 
            UI.startScreen.classList.remove('flex');
            UI.playerSetup.classList.remove('hidden'); 
            UI.playerSetup.classList.add('flex'); 
            updateAbilityDisplay(); 
        });
        setupButtonClick(UI.loadGameBtn, () => { 
            sessionStorage.removeItem('synapse_session_v15_autosave'); 
            sessionStorage.removeItem('synapse_session_v15_screen_state'); 
            loadGame(); 
        });
        setupButtonClick(UI.backToStartBtn, () => {
            UI.playerSetup.classList.add('hidden');
            UI.playerSetup.classList.remove('flex');
            UI.startScreen.classList.remove('hidden');
            UI.startScreen.classList.add('flex');
        });
        setupButtonClick(UI.viewFeaturesBtn, showFeaturesModal);
        setupButtonClick(UI.startSettingsBtn, () => showSettingsModal(false));
        setupButtonClick(UI.startGameBtn, startGame);
        setupButtonClick(UI.viewBackstoriesBtn, showBackstoryModal);
        setupButtonClick(UI.statusBtn, showStatusModal);
        setupButtonClick(UI.viewProgressionBtn, showProgressionModal);
        setupButtonClick(UI.mapToggleBtn, toggleMapFullscreen);
        setupButtonClick(UI.mapLayersBtn, () => { showGuidance("Map layer functionality is not yet implemented."); });
        
        setupButtonClick(UI.langEnBtn, setLanguage, 'en');
        setupButtonClick(UI.langSvBtn, setLanguage, 'sv');
        
        const setupLangEnBtn = UI.setupLangButtons.children[0];
        const setupLangSvBtn = UI.setupLangButtons.children[1];
        setupButtonClick(setupLangEnBtn, setLanguage, 'en');
        setupButtonClick(setupLangSvBtn, setLanguage, 'sv');

        setupButtonClick(UI.setupSettingsBtn, () => showSettingsModal(false));
        setupButtonClick(UI.setupFeaturesBtn, showFeaturesModal);

        UI.difficultyBtns.forEach(btn => { setupButtonClick(btn, () => { UI.difficultyBtns.forEach(b => b.classList.remove('button-primary')); btn.classList.add('button-primary'); updateAbilityDisplay(); }); });
        UI.playerBackstoryInput.addEventListener('input', updateAbilityDisplay);
        
        if (SpeechRecognition) {
            setupButtonClick(UI.micBtn, startSpeechRecognition);
        } else {
            UI.micBtn.style.display = 'none';
        }

        let restored = false;

        if (loadStateFromSession()) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            gameLoop();
            restored = true;
        } 
        else {
            const screenStateData = sessionStorage.getItem('synapse_session_v15_screen_state');
            if (screenStateData) {
                try {
                    const startState = JSON.parse(screenStateData);
                    setLanguage(startState.language || 'en'); 

                    if (startState.isPlayerSetupVisible) {
                        UI.startScreen.classList.add('hidden');
                        UI.startScreen.classList.remove('flex');
                        UI.playerSetup.classList.remove('hidden');
                        UI.playerSetup.classList.add('flex');
                        
                        UI.playerNameInput.value = startState.playerName || '';
                        UI.playerBackstoryInput.value = startState.playerBackstory || '';
                        UI.difficultyBtns.forEach(btn => btn.classList.remove('button-primary'));
                        const difficultyBtn = Array.from(UI.difficultyBtns).find(b => b.dataset.difficulty === startState.difficulty) || UI.difficultyBtns[1];
                        difficultyBtn.classList.add('button-primary');
                        updateAbilityDisplay();
                    }
                    restored = true;
                } catch (e) {
                    console.error("Failed to restore screen state:", e);
                    sessionStorage.removeItem('synapse_session_v15_screen_state');
                }
            }
        }

        if (!restored) {
            resetGameState();
            setLanguage('en');
            setTimeout(() => {
                const playerLayout = roomLayout[GameState.currentRoom];
                if(playerLayout && UI.mapCanvas.offsetWidth > 0 && UI.mapCanvas.offsetHeight > 0) {
                     mapState.offsetX = (UI.mapCanvas.offsetWidth / 2) - (playerLayout.x + playerLayout.w / 2) * mapState.scale;
                     mapState.offsetY = (UI.mapCanvas.offsetHeight / 2) - (playerLayout.y + playerLayout.h / 2) * mapState.scale;
                }
            }, 100);
        }

        initMapControls();
        setupBackgroundAnimation();
    });
    </script>
</body>
</html>
